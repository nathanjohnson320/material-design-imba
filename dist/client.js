/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/client.imba");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/@material/base/component.js":
/*!**************************************************!*\
  !*** ./node_modules/@material/base/component.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _foundation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./foundation */ \"./node_modules/@material/base/foundation.js\");\n/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n\n/**\n * @template F\n */\nclass MDCComponent {\n  /**\n   * @param {!Element} root\n   * @return {!MDCComponent}\n   */\n  static attachTo(root) {\n    // Subclasses which extend MDCBase should provide an attachTo() method that takes a root element and\n    // returns an instantiated component with its root set to that element. Also note that in the cases of\n    // subclasses, an explicit foundation class will not have to be passed in; it will simply be initialized\n    // from getDefaultFoundation().\n    return new MDCComponent(root, new _foundation__WEBPACK_IMPORTED_MODULE_0__[\"default\"]());\n  }\n\n  /**\n   * @param {!Element} root\n   * @param {F=} foundation\n   * @param {...?} args\n   */\n  constructor(root, foundation = undefined, ...args) {\n    /** @protected {!Element} */\n    this.root_ = root;\n    this.initialize(...args);\n    // Note that we initialize foundation here and not within the constructor's default param so that\n    // this.root_ is defined and can be used within the foundation class.\n    /** @protected {!F} */\n    this.foundation_ = foundation === undefined ? this.getDefaultFoundation() : foundation;\n    this.foundation_.init();\n    this.initialSyncWithDOM();\n  }\n\n  initialize(/* ...args */) {\n    // Subclasses can override this to do any additional setup work that would be considered part of a\n    // \"constructor\". Essentially, it is a hook into the parent constructor before the foundation is\n    // initialized. Any additional arguments besides root and foundation will be passed in here.\n  }\n\n  /**\n   * @return {!F} foundation\n   */\n  getDefaultFoundation() {\n    // Subclasses must override this method to return a properly configured foundation class for the\n    // component.\n    throw new Error('Subclasses must override getDefaultFoundation to return a properly configured ' +\n      'foundation class');\n  }\n\n  initialSyncWithDOM() {\n    // Subclasses should override this method if they need to perform work to synchronize with a host DOM\n    // object. An example of this would be a form control wrapper that needs to synchronize its internal state\n    // to some property or attribute of the host DOM. Please note: this is *not* the place to perform DOM\n    // reads/writes that would cause layout / paint, as this is called synchronously from within the constructor.\n  }\n\n  destroy() {\n    // Subclasses may implement this method to release any resources / deregister any listeners they have\n    // attached. An example of this might be deregistering a resize event from the window object.\n    this.foundation_.destroy();\n  }\n\n  /**\n   * Wrapper method to add an event listener to the component's root element. This is most useful when\n   * listening for custom events.\n   * @param {string} evtType\n   * @param {!Function} handler\n   */\n  listen(evtType, handler) {\n    this.root_.addEventListener(evtType, handler);\n  }\n\n  /**\n   * Wrapper method to remove an event listener to the component's root element. This is most useful when\n   * unlistening for custom events.\n   * @param {string} evtType\n   * @param {!Function} handler\n   */\n  unlisten(evtType, handler) {\n    this.root_.removeEventListener(evtType, handler);\n  }\n\n  /**\n   * Fires a cross-browser-compatible custom event from the component root of the given type,\n   * with the given data.\n   * @param {string} evtType\n   * @param {!Object} evtData\n   * @param {boolean=} shouldBubble\n   */\n  emit(evtType, evtData, shouldBubble = false) {\n    let evt;\n    if (typeof CustomEvent === 'function') {\n      evt = new CustomEvent(evtType, {\n        detail: evtData,\n        bubbles: shouldBubble,\n      });\n    } else {\n      evt = document.createEvent('CustomEvent');\n      evt.initCustomEvent(evtType, shouldBubble, false, evtData);\n    }\n\n    this.root_.dispatchEvent(evt);\n  }\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (MDCComponent);\n\n\n//# sourceURL=webpack:///./node_modules/@material/base/component.js?");

/***/ }),

/***/ "./node_modules/@material/base/foundation.js":
/*!***************************************************!*\
  !*** ./node_modules/@material/base/foundation.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @template A\n */\nclass MDCFoundation {\n  /** @return enum{cssClasses} */\n  static get cssClasses() {\n    // Classes extending MDCFoundation should implement this method to return an object which exports every\n    // CSS class the foundation class needs as a property. e.g. {ACTIVE: 'mdc-component--active'}\n    return {};\n  }\n\n  /** @return enum{strings} */\n  static get strings() {\n    // Classes extending MDCFoundation should implement this method to return an object which exports all\n    // semantic strings as constants. e.g. {ARIA_ROLE: 'tablist'}\n    return {};\n  }\n\n  /** @return enum{numbers} */\n  static get numbers() {\n    // Classes extending MDCFoundation should implement this method to return an object which exports all\n    // of its semantic numbers as constants. e.g. {ANIMATION_DELAY_MS: 350}\n    return {};\n  }\n\n  /** @return {!Object} */\n  static get defaultAdapter() {\n    // Classes extending MDCFoundation may choose to implement this getter in order to provide a convenient\n    // way of viewing the necessary methods of an adapter. In the future, this could also be used for adapter\n    // validation.\n    return {};\n  }\n\n  /**\n   * @param {A=} adapter\n   */\n  constructor(adapter = {}) {\n    /** @protected {!A} */\n    this.adapter_ = adapter;\n  }\n\n  init() {\n    // Subclasses should override this method to perform initialization routines (registering events, etc.)\n  }\n\n  destroy() {\n    // Subclasses should override this method to perform de-initialization routines (de-registering events, etc.)\n  }\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (MDCFoundation);\n\n\n//# sourceURL=webpack:///./node_modules/@material/base/foundation.js?");

/***/ }),

/***/ "./node_modules/@material/button/mdc-button.scss":
/*!*******************************************************!*\
  !*** ./node_modules/@material/button/mdc-button.scss ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\nvar content = __webpack_require__(/*! !../../css-loader!../../sass-loader/lib/loader.js??ref--5-2!./mdc-button.scss */ \"./node_modules/css-loader/index.js!./node_modules/sass-loader/lib/loader.js?!./node_modules/@material/button/mdc-button.scss\");\n\nif(typeof content === 'string') content = [[module.i, content, '']];\n\nvar transform;\nvar insertInto;\n\n\n\nvar options = {\"hmr\":true}\n\noptions.transform = transform\noptions.insertInto = undefined;\n\nvar update = __webpack_require__(/*! ../../style-loader/lib/addStyles.js */ \"./node_modules/style-loader/lib/addStyles.js\")(content, options);\n\nif(content.locals) module.exports = content.locals;\n\nif(false) {}\n\n//# sourceURL=webpack:///./node_modules/@material/button/mdc-button.scss?");

/***/ }),

/***/ "./node_modules/@material/ripple/adapter.js":
/*!**************************************************!*\
  !*** ./node_modules/@material/ripple/adapter.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/**\n * @license\n * Copyright 2016 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/* eslint no-unused-vars: [2, {\"args\": \"none\"}] */\n\n/**\n * Adapter for MDC Ripple. Provides an interface for managing\n * - classes\n * - dom\n * - CSS variables\n * - position\n * - dimensions\n * - scroll position\n * - event handlers\n * - unbounded, active and disabled states\n *\n * Additionally, provides type information for the adapter to the Closure\n * compiler.\n *\n * Implement this adapter for your framework of choice to delegate updates to\n * the component in your framework of choice. See architecture documentation\n * for more details.\n * https://github.com/material-components/material-components-web/blob/master/docs/code/architecture.md\n *\n * @record\n */\nclass MDCRippleAdapter {\n  /** @return {boolean} */\n  browserSupportsCssVars() {}\n\n  /** @return {boolean} */\n  isUnbounded() {}\n\n  /** @return {boolean} */\n  isSurfaceActive() {}\n\n  /** @return {boolean} */\n  isSurfaceDisabled() {}\n\n  /** @param {string} className */\n  addClass(className) {}\n\n  /** @param {string} className */\n  removeClass(className) {}\n\n  /** @param {!EventTarget} target */\n  containsEventTarget(target) {}\n\n  /**\n   * @param {string} evtType\n   * @param {!Function} handler\n   */\n  registerInteractionHandler(evtType, handler) {}\n\n  /**\n   * @param {string} evtType\n   * @param {!Function} handler\n   */\n  deregisterInteractionHandler(evtType, handler) {}\n\n  /**\n   * @param {string} evtType\n   * @param {!Function} handler\n   */\n  registerDocumentInteractionHandler(evtType, handler) {}\n\n  /**\n   * @param {string} evtType\n   * @param {!Function} handler\n   */\n  deregisterDocumentInteractionHandler(evtType, handler) {}\n\n  /**\n   * @param {!Function} handler\n   */\n  registerResizeHandler(handler) {}\n\n  /**\n   * @param {!Function} handler\n   */\n  deregisterResizeHandler(handler) {}\n\n  /**\n   * @param {string} varName\n   * @param {?number|string} value\n   */\n  updateCssVariable(varName, value) {}\n\n  /** @return {!ClientRect} */\n  computeBoundingRect() {}\n\n  /** @return {{x: number, y: number}} */\n  getWindowPageOffset() {}\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (MDCRippleAdapter);\n\n\n//# sourceURL=webpack:///./node_modules/@material/ripple/adapter.js?");

/***/ }),

/***/ "./node_modules/@material/ripple/constants.js":
/*!****************************************************!*\
  !*** ./node_modules/@material/ripple/constants.js ***!
  \****************************************************/
/*! exports provided: cssClasses, strings, numbers */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"cssClasses\", function() { return cssClasses; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"strings\", function() { return strings; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"numbers\", function() { return numbers; });\n/**\n * @license\n * Copyright 2016 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nconst cssClasses = {\n  // Ripple is a special case where the \"root\" component is really a \"mixin\" of sorts,\n  // given that it's an 'upgrade' to an existing component. That being said it is the root\n  // CSS class that all other CSS classes derive from.\n  ROOT: 'mdc-ripple-upgraded',\n  UNBOUNDED: 'mdc-ripple-upgraded--unbounded',\n  BG_FOCUSED: 'mdc-ripple-upgraded--background-focused',\n  FG_ACTIVATION: 'mdc-ripple-upgraded--foreground-activation',\n  FG_DEACTIVATION: 'mdc-ripple-upgraded--foreground-deactivation',\n};\n\nconst strings = {\n  VAR_LEFT: '--mdc-ripple-left',\n  VAR_TOP: '--mdc-ripple-top',\n  VAR_FG_SIZE: '--mdc-ripple-fg-size',\n  VAR_FG_SCALE: '--mdc-ripple-fg-scale',\n  VAR_FG_TRANSLATE_START: '--mdc-ripple-fg-translate-start',\n  VAR_FG_TRANSLATE_END: '--mdc-ripple-fg-translate-end',\n};\n\nconst numbers = {\n  PADDING: 10,\n  INITIAL_ORIGIN_SCALE: 0.6,\n  DEACTIVATION_TIMEOUT_MS: 225, // Corresponds to $mdc-ripple-translate-duration (i.e. activation animation duration)\n  FG_DEACTIVATION_MS: 150, // Corresponds to $mdc-ripple-fade-out-duration (i.e. deactivation animation duration)\n  TAP_DELAY_MS: 300, // Delay between touch and simulated mouse events on touch devices\n};\n\n\n\n\n//# sourceURL=webpack:///./node_modules/@material/ripple/constants.js?");

/***/ }),

/***/ "./node_modules/@material/ripple/foundation.js":
/*!*****************************************************!*\
  !*** ./node_modules/@material/ripple/foundation.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _material_base_foundation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @material/base/foundation */ \"./node_modules/@material/base/foundation.js\");\n/* harmony import */ var _adapter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./adapter */ \"./node_modules/@material/ripple/adapter.js\");\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./constants */ \"./node_modules/@material/ripple/constants.js\");\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./util */ \"./node_modules/@material/ripple/util.js\");\n/**\n * @license\n * Copyright 2016 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n\n\n\n\n/**\n * @typedef {{\n *   isActivated: (boolean|undefined),\n *   hasDeactivationUXRun: (boolean|undefined),\n *   wasActivatedByPointer: (boolean|undefined),\n *   wasElementMadeActive: (boolean|undefined),\n *   activationEvent: Event,\n *   isProgrammatic: (boolean|undefined)\n * }}\n */\nlet ActivationStateType;\n\n/**\n * @typedef {{\n *   activate: (string|undefined),\n *   deactivate: (string|undefined),\n *   focus: (string|undefined),\n *   blur: (string|undefined)\n * }}\n */\nlet ListenerInfoType;\n\n/**\n * @typedef {{\n *   activate: function(!Event),\n *   deactivate: function(!Event),\n *   focus: function(),\n *   blur: function()\n * }}\n */\nlet ListenersType;\n\n/**\n * @typedef {{\n *   x: number,\n *   y: number\n * }}\n */\nlet PointType;\n\n// Activation events registered on the root element of each instance for activation\nconst ACTIVATION_EVENT_TYPES = ['touchstart', 'pointerdown', 'mousedown', 'keydown'];\n\n// Deactivation events registered on documentElement when a pointer-related down event occurs\nconst POINTER_DEACTIVATION_EVENT_TYPES = ['touchend', 'pointerup', 'mouseup'];\n\n// Tracks activations that have occurred on the current frame, to avoid simultaneous nested activations\n/** @type {!Array<!EventTarget>} */\nlet activatedTargets = [];\n\n/**\n * @extends {MDCFoundation<!MDCRippleAdapter>}\n */\nclass MDCRippleFoundation extends _material_base_foundation__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n  static get cssClasses() {\n    return _constants__WEBPACK_IMPORTED_MODULE_2__[\"cssClasses\"];\n  }\n\n  static get strings() {\n    return _constants__WEBPACK_IMPORTED_MODULE_2__[\"strings\"];\n  }\n\n  static get numbers() {\n    return _constants__WEBPACK_IMPORTED_MODULE_2__[\"numbers\"];\n  }\n\n  static get defaultAdapter() {\n    return {\n      browserSupportsCssVars: () => /* boolean - cached */ {},\n      isUnbounded: () => /* boolean */ {},\n      isSurfaceActive: () => /* boolean */ {},\n      isSurfaceDisabled: () => /* boolean */ {},\n      addClass: (/* className: string */) => {},\n      removeClass: (/* className: string */) => {},\n      containsEventTarget: (/* target: !EventTarget */) => {},\n      registerInteractionHandler: (/* evtType: string, handler: EventListener */) => {},\n      deregisterInteractionHandler: (/* evtType: string, handler: EventListener */) => {},\n      registerDocumentInteractionHandler: (/* evtType: string, handler: EventListener */) => {},\n      deregisterDocumentInteractionHandler: (/* evtType: string, handler: EventListener */) => {},\n      registerResizeHandler: (/* handler: EventListener */) => {},\n      deregisterResizeHandler: (/* handler: EventListener */) => {},\n      updateCssVariable: (/* varName: string, value: string */) => {},\n      computeBoundingRect: () => /* ClientRect */ {},\n      getWindowPageOffset: () => /* {x: number, y: number} */ {},\n    };\n  }\n\n  constructor(adapter) {\n    super(Object.assign(MDCRippleFoundation.defaultAdapter, adapter));\n\n    /** @private {number} */\n    this.layoutFrame_ = 0;\n\n    /** @private {!ClientRect} */\n    this.frame_ = /** @type {!ClientRect} */ ({width: 0, height: 0});\n\n    /** @private {!ActivationStateType} */\n    this.activationState_ = this.defaultActivationState_();\n\n    /** @private {number} */\n    this.initialSize_ = 0;\n\n    /** @private {number} */\n    this.maxRadius_ = 0;\n\n    /** @private {function(!Event)} */\n    this.activateHandler_ = (e) => this.activate_(e);\n\n    /** @private {function(!Event)} */\n    this.deactivateHandler_ = (e) => this.deactivate_(e);\n\n    /** @private {function(?Event=)} */\n    this.focusHandler_ = () => this.handleFocus();\n\n    /** @private {function(?Event=)} */\n    this.blurHandler_ = () => this.handleBlur();\n\n    /** @private {!Function} */\n    this.resizeHandler_ = () => this.layout();\n\n    /** @private {{left: number, top:number}} */\n    this.unboundedCoords_ = {\n      left: 0,\n      top: 0,\n    };\n\n    /** @private {number} */\n    this.fgScale_ = 0;\n\n    /** @private {number} */\n    this.activationTimer_ = 0;\n\n    /** @private {number} */\n    this.fgDeactivationRemovalTimer_ = 0;\n\n    /** @private {boolean} */\n    this.activationAnimationHasEnded_ = false;\n\n    /** @private {!Function} */\n    this.activationTimerCallback_ = () => {\n      this.activationAnimationHasEnded_ = true;\n      this.runDeactivationUXLogicIfReady_();\n    };\n\n    /** @private {?Event} */\n    this.previousActivationEvent_ = null;\n  }\n\n  /**\n   * We compute this property so that we are not querying information about the client\n   * until the point in time where the foundation requests it. This prevents scenarios where\n   * client-side feature-detection may happen too early, such as when components are rendered on the server\n   * and then initialized at mount time on the client.\n   * @return {boolean}\n   * @private\n   */\n  isSupported_() {\n    return this.adapter_.browserSupportsCssVars();\n  }\n\n  /**\n   * @return {!ActivationStateType}\n   */\n  defaultActivationState_() {\n    return {\n      isActivated: false,\n      hasDeactivationUXRun: false,\n      wasActivatedByPointer: false,\n      wasElementMadeActive: false,\n      activationEvent: null,\n      isProgrammatic: false,\n    };\n  }\n\n  init() {\n    if (!this.isSupported_()) {\n      return;\n    }\n    this.registerRootHandlers_();\n\n    const {ROOT, UNBOUNDED} = MDCRippleFoundation.cssClasses;\n    requestAnimationFrame(() => {\n      this.adapter_.addClass(ROOT);\n      if (this.adapter_.isUnbounded()) {\n        this.adapter_.addClass(UNBOUNDED);\n        // Unbounded ripples need layout logic applied immediately to set coordinates for both shade and ripple\n        this.layoutInternal_();\n      }\n    });\n  }\n\n  destroy() {\n    if (!this.isSupported_()) {\n      return;\n    }\n\n    if (this.activationTimer_) {\n      clearTimeout(this.activationTimer_);\n      this.activationTimer_ = 0;\n      const {FG_ACTIVATION} = MDCRippleFoundation.cssClasses;\n      this.adapter_.removeClass(FG_ACTIVATION);\n    }\n\n    this.deregisterRootHandlers_();\n    this.deregisterDeactivationHandlers_();\n\n    const {ROOT, UNBOUNDED} = MDCRippleFoundation.cssClasses;\n    requestAnimationFrame(() => {\n      this.adapter_.removeClass(ROOT);\n      this.adapter_.removeClass(UNBOUNDED);\n      this.removeCssVars_();\n    });\n  }\n\n  /** @private */\n  registerRootHandlers_() {\n    ACTIVATION_EVENT_TYPES.forEach((type) => {\n      this.adapter_.registerInteractionHandler(type, this.activateHandler_);\n    });\n    this.adapter_.registerInteractionHandler('focus', this.focusHandler_);\n    this.adapter_.registerInteractionHandler('blur', this.blurHandler_);\n\n    if (this.adapter_.isUnbounded()) {\n      this.adapter_.registerResizeHandler(this.resizeHandler_);\n    }\n  }\n\n  /**\n   * @param {!Event} e\n   * @private\n   */\n  registerDeactivationHandlers_(e) {\n    if (e.type === 'keydown') {\n      this.adapter_.registerInteractionHandler('keyup', this.deactivateHandler_);\n    } else {\n      POINTER_DEACTIVATION_EVENT_TYPES.forEach((type) => {\n        this.adapter_.registerDocumentInteractionHandler(type, this.deactivateHandler_);\n      });\n    }\n  }\n\n  /** @private */\n  deregisterRootHandlers_() {\n    ACTIVATION_EVENT_TYPES.forEach((type) => {\n      this.adapter_.deregisterInteractionHandler(type, this.activateHandler_);\n    });\n    this.adapter_.deregisterInteractionHandler('focus', this.focusHandler_);\n    this.adapter_.deregisterInteractionHandler('blur', this.blurHandler_);\n\n    if (this.adapter_.isUnbounded()) {\n      this.adapter_.deregisterResizeHandler(this.resizeHandler_);\n    }\n  }\n\n  /** @private */\n  deregisterDeactivationHandlers_() {\n    this.adapter_.deregisterInteractionHandler('keyup', this.deactivateHandler_);\n    POINTER_DEACTIVATION_EVENT_TYPES.forEach((type) => {\n      this.adapter_.deregisterDocumentInteractionHandler(type, this.deactivateHandler_);\n    });\n  }\n\n  /** @private */\n  removeCssVars_() {\n    const {strings} = MDCRippleFoundation;\n    Object.keys(strings).forEach((k) => {\n      if (k.indexOf('VAR_') === 0) {\n        this.adapter_.updateCssVariable(strings[k], null);\n      }\n    });\n  }\n\n  /**\n   * @param {?Event} e\n   * @private\n   */\n  activate_(e) {\n    if (this.adapter_.isSurfaceDisabled()) {\n      return;\n    }\n\n    const activationState = this.activationState_;\n    if (activationState.isActivated) {\n      return;\n    }\n\n    // Avoid reacting to follow-on events fired by touch device after an already-processed user interaction\n    const previousActivationEvent = this.previousActivationEvent_;\n    const isSameInteraction = previousActivationEvent && e && previousActivationEvent.type !== e.type;\n    if (isSameInteraction) {\n      return;\n    }\n\n    activationState.isActivated = true;\n    activationState.isProgrammatic = e === null;\n    activationState.activationEvent = e;\n    activationState.wasActivatedByPointer = activationState.isProgrammatic ? false : (\n      e.type === 'mousedown' || e.type === 'touchstart' || e.type === 'pointerdown'\n    );\n\n    const hasActivatedChild =\n      e && activatedTargets.length > 0 && activatedTargets.some((target) => this.adapter_.containsEventTarget(target));\n    if (hasActivatedChild) {\n      // Immediately reset activation state, while preserving logic that prevents touch follow-on events\n      this.resetActivationState_();\n      return;\n    }\n\n    if (e) {\n      activatedTargets.push(/** @type {!EventTarget} */ (e.target));\n      this.registerDeactivationHandlers_(e);\n    }\n\n    activationState.wasElementMadeActive = this.checkElementMadeActive_(e);\n    if (activationState.wasElementMadeActive) {\n      this.animateActivation_();\n    }\n\n    requestAnimationFrame(() => {\n      // Reset array on next frame after the current event has had a chance to bubble to prevent ancestor ripples\n      activatedTargets = [];\n\n      if (!activationState.wasElementMadeActive && (e.key === ' ' || e.keyCode === 32)) {\n        // If space was pressed, try again within an rAF call to detect :active, because different UAs report\n        // active states inconsistently when they're called within event handling code:\n        // - https://bugs.chromium.org/p/chromium/issues/detail?id=635971\n        // - https://bugzilla.mozilla.org/show_bug.cgi?id=1293741\n        // We try first outside rAF to support Edge, which does not exhibit this problem, but will crash if a CSS\n        // variable is set within a rAF callback for a submit button interaction (#2241).\n        activationState.wasElementMadeActive = this.checkElementMadeActive_(e);\n        if (activationState.wasElementMadeActive) {\n          this.animateActivation_();\n        }\n      }\n\n      if (!activationState.wasElementMadeActive) {\n        // Reset activation state immediately if element was not made active.\n        this.activationState_ = this.defaultActivationState_();\n      }\n    });\n  }\n\n  /**\n   * @param {?Event} e\n   * @private\n   */\n  checkElementMadeActive_(e) {\n    return (e && e.type === 'keydown') ? this.adapter_.isSurfaceActive() : true;\n  }\n\n  /**\n   * @param {?Event=} event Optional event containing position information.\n   */\n  activate(event = null) {\n    this.activate_(event);\n  }\n\n  /** @private */\n  animateActivation_() {\n    const {VAR_FG_TRANSLATE_START, VAR_FG_TRANSLATE_END} = MDCRippleFoundation.strings;\n    const {FG_DEACTIVATION, FG_ACTIVATION} = MDCRippleFoundation.cssClasses;\n    const {DEACTIVATION_TIMEOUT_MS} = MDCRippleFoundation.numbers;\n\n    this.layoutInternal_();\n\n    let translateStart = '';\n    let translateEnd = '';\n\n    if (!this.adapter_.isUnbounded()) {\n      const {startPoint, endPoint} = this.getFgTranslationCoordinates_();\n      translateStart = `${startPoint.x}px, ${startPoint.y}px`;\n      translateEnd = `${endPoint.x}px, ${endPoint.y}px`;\n    }\n\n    this.adapter_.updateCssVariable(VAR_FG_TRANSLATE_START, translateStart);\n    this.adapter_.updateCssVariable(VAR_FG_TRANSLATE_END, translateEnd);\n    // Cancel any ongoing activation/deactivation animations\n    clearTimeout(this.activationTimer_);\n    clearTimeout(this.fgDeactivationRemovalTimer_);\n    this.rmBoundedActivationClasses_();\n    this.adapter_.removeClass(FG_DEACTIVATION);\n\n    // Force layout in order to re-trigger the animation.\n    this.adapter_.computeBoundingRect();\n    this.adapter_.addClass(FG_ACTIVATION);\n    this.activationTimer_ = setTimeout(() => this.activationTimerCallback_(), DEACTIVATION_TIMEOUT_MS);\n  }\n\n  /**\n   * @private\n   * @return {{startPoint: PointType, endPoint: PointType}}\n   */\n  getFgTranslationCoordinates_() {\n    const {activationEvent, wasActivatedByPointer} = this.activationState_;\n\n    let startPoint;\n    if (wasActivatedByPointer) {\n      startPoint = Object(_util__WEBPACK_IMPORTED_MODULE_3__[\"getNormalizedEventCoords\"])(\n        /** @type {!Event} */ (activationEvent),\n        this.adapter_.getWindowPageOffset(), this.adapter_.computeBoundingRect()\n      );\n    } else {\n      startPoint = {\n        x: this.frame_.width / 2,\n        y: this.frame_.height / 2,\n      };\n    }\n    // Center the element around the start point.\n    startPoint = {\n      x: startPoint.x - (this.initialSize_ / 2),\n      y: startPoint.y - (this.initialSize_ / 2),\n    };\n\n    const endPoint = {\n      x: (this.frame_.width / 2) - (this.initialSize_ / 2),\n      y: (this.frame_.height / 2) - (this.initialSize_ / 2),\n    };\n\n    return {startPoint, endPoint};\n  }\n\n  /** @private */\n  runDeactivationUXLogicIfReady_() {\n    // This method is called both when a pointing device is released, and when the activation animation ends.\n    // The deactivation animation should only run after both of those occur.\n    const {FG_DEACTIVATION} = MDCRippleFoundation.cssClasses;\n    const {hasDeactivationUXRun, isActivated} = this.activationState_;\n    const activationHasEnded = hasDeactivationUXRun || !isActivated;\n\n    if (activationHasEnded && this.activationAnimationHasEnded_) {\n      this.rmBoundedActivationClasses_();\n      this.adapter_.addClass(FG_DEACTIVATION);\n      this.fgDeactivationRemovalTimer_ = setTimeout(() => {\n        this.adapter_.removeClass(FG_DEACTIVATION);\n      }, _constants__WEBPACK_IMPORTED_MODULE_2__[\"numbers\"].FG_DEACTIVATION_MS);\n    }\n  }\n\n  /** @private */\n  rmBoundedActivationClasses_() {\n    const {FG_ACTIVATION} = MDCRippleFoundation.cssClasses;\n    this.adapter_.removeClass(FG_ACTIVATION);\n    this.activationAnimationHasEnded_ = false;\n    this.adapter_.computeBoundingRect();\n  }\n\n  resetActivationState_() {\n    this.previousActivationEvent_ = this.activationState_.activationEvent;\n    this.activationState_ = this.defaultActivationState_();\n    // Touch devices may fire additional events for the same interaction within a short time.\n    // Store the previous event until it's safe to assume that subsequent events are for new interactions.\n    setTimeout(() => this.previousActivationEvent_ = null, MDCRippleFoundation.numbers.TAP_DELAY_MS);\n  }\n\n  /**\n   * @param {?Event} e\n   * @private\n   */\n  deactivate_(e) {\n    const activationState = this.activationState_;\n    // This can happen in scenarios such as when you have a keyup event that blurs the element.\n    if (!activationState.isActivated) {\n      return;\n    }\n\n    const state = /** @type {!ActivationStateType} */ (Object.assign({}, activationState));\n\n    if (activationState.isProgrammatic) {\n      const evtObject = null;\n      requestAnimationFrame(() => this.animateDeactivation_(evtObject, state));\n      this.resetActivationState_();\n    } else {\n      this.deregisterDeactivationHandlers_();\n      requestAnimationFrame(() => {\n        this.activationState_.hasDeactivationUXRun = true;\n        this.animateDeactivation_(e, state);\n        this.resetActivationState_();\n      });\n    }\n  }\n\n  /**\n   * @param {?Event=} event Optional event containing position information.\n   */\n  deactivate(event = null) {\n    this.deactivate_(event);\n  }\n\n  /**\n   * @param {Event} e\n   * @param {!ActivationStateType} options\n   * @private\n   */\n  animateDeactivation_(e, {wasActivatedByPointer, wasElementMadeActive}) {\n    if (wasActivatedByPointer || wasElementMadeActive) {\n      this.runDeactivationUXLogicIfReady_();\n    }\n  }\n\n  layout() {\n    if (this.layoutFrame_) {\n      cancelAnimationFrame(this.layoutFrame_);\n    }\n    this.layoutFrame_ = requestAnimationFrame(() => {\n      this.layoutInternal_();\n      this.layoutFrame_ = 0;\n    });\n  }\n\n  /** @private */\n  layoutInternal_() {\n    this.frame_ = this.adapter_.computeBoundingRect();\n    const maxDim = Math.max(this.frame_.height, this.frame_.width);\n\n    // Surface diameter is treated differently for unbounded vs. bounded ripples.\n    // Unbounded ripple diameter is calculated smaller since the surface is expected to already be padded appropriately\n    // to extend the hitbox, and the ripple is expected to meet the edges of the padded hitbox (which is typically\n    // square). Bounded ripples, on the other hand, are fully expected to expand beyond the surface's longest diameter\n    // (calculated based on the diagonal plus a constant padding), and are clipped at the surface's border via\n    // `overflow: hidden`.\n    const getBoundedRadius = () => {\n      const hypotenuse = Math.sqrt(Math.pow(this.frame_.width, 2) + Math.pow(this.frame_.height, 2));\n      return hypotenuse + MDCRippleFoundation.numbers.PADDING;\n    };\n\n    this.maxRadius_ = this.adapter_.isUnbounded() ? maxDim : getBoundedRadius();\n\n    // Ripple is sized as a fraction of the largest dimension of the surface, then scales up using a CSS scale transform\n    this.initialSize_ = maxDim * MDCRippleFoundation.numbers.INITIAL_ORIGIN_SCALE;\n    this.fgScale_ = this.maxRadius_ / this.initialSize_;\n\n    this.updateLayoutCssVars_();\n  }\n\n  /** @private */\n  updateLayoutCssVars_() {\n    const {\n      VAR_FG_SIZE, VAR_LEFT, VAR_TOP, VAR_FG_SCALE,\n    } = MDCRippleFoundation.strings;\n\n    this.adapter_.updateCssVariable(VAR_FG_SIZE, `${this.initialSize_}px`);\n    this.adapter_.updateCssVariable(VAR_FG_SCALE, this.fgScale_);\n\n    if (this.adapter_.isUnbounded()) {\n      this.unboundedCoords_ = {\n        left: Math.round((this.frame_.width / 2) - (this.initialSize_ / 2)),\n        top: Math.round((this.frame_.height / 2) - (this.initialSize_ / 2)),\n      };\n\n      this.adapter_.updateCssVariable(VAR_LEFT, `${this.unboundedCoords_.left}px`);\n      this.adapter_.updateCssVariable(VAR_TOP, `${this.unboundedCoords_.top}px`);\n    }\n  }\n\n  /** @param {boolean} unbounded */\n  setUnbounded(unbounded) {\n    const {UNBOUNDED} = MDCRippleFoundation.cssClasses;\n    if (unbounded) {\n      this.adapter_.addClass(UNBOUNDED);\n    } else {\n      this.adapter_.removeClass(UNBOUNDED);\n    }\n  }\n\n  handleFocus() {\n    requestAnimationFrame(() =>\n      this.adapter_.addClass(MDCRippleFoundation.cssClasses.BG_FOCUSED));\n  }\n\n  handleBlur() {\n    requestAnimationFrame(() =>\n      this.adapter_.removeClass(MDCRippleFoundation.cssClasses.BG_FOCUSED));\n  }\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (MDCRippleFoundation);\n\n\n//# sourceURL=webpack:///./node_modules/@material/ripple/foundation.js?");

/***/ }),

/***/ "./node_modules/@material/ripple/index.js":
/*!************************************************!*\
  !*** ./node_modules/@material/ripple/index.js ***!
  \************************************************/
/*! exports provided: MDCRipple, MDCRippleFoundation, RippleCapableSurface, util */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MDCRipple\", function() { return MDCRipple; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RippleCapableSurface\", function() { return RippleCapableSurface; });\n/* harmony import */ var _material_base_component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @material/base/component */ \"./node_modules/@material/base/component.js\");\n/* harmony import */ var _adapter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./adapter */ \"./node_modules/@material/ripple/adapter.js\");\n/* harmony import */ var _foundation__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./foundation */ \"./node_modules/@material/ripple/foundation.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"MDCRippleFoundation\", function() { return _foundation__WEBPACK_IMPORTED_MODULE_2__[\"default\"]; });\n\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./util */ \"./node_modules/@material/ripple/util.js\");\n/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, \"util\", function() { return _util__WEBPACK_IMPORTED_MODULE_3__; });\n/**\n * @license\n * Copyright 2016 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n\n\n\n\n/**\n * @extends MDCComponent<!MDCRippleFoundation>\n */\nclass MDCRipple extends _material_base_component__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n  /** @param {...?} args */\n  constructor(...args) {\n    super(...args);\n\n    /** @type {boolean} */\n    this.disabled = false;\n\n    /** @private {boolean} */\n    this.unbounded_;\n  }\n\n  /**\n   * @param {!Element} root\n   * @param {{isUnbounded: (boolean|undefined)}=} options\n   * @return {!MDCRipple}\n   */\n  static attachTo(root, {isUnbounded = undefined} = {}) {\n    const ripple = new MDCRipple(root);\n    // Only override unbounded behavior if option is explicitly specified\n    if (isUnbounded !== undefined) {\n      ripple.unbounded = /** @type {boolean} */ (isUnbounded);\n    }\n    return ripple;\n  }\n\n  /**\n   * @param {!RippleCapableSurface} instance\n   * @return {!MDCRippleAdapter}\n   */\n  static createAdapter(instance) {\n    const MATCHES = _util__WEBPACK_IMPORTED_MODULE_3__[\"getMatchesProperty\"](HTMLElement.prototype);\n\n    return {\n      browserSupportsCssVars: () => _util__WEBPACK_IMPORTED_MODULE_3__[\"supportsCssVariables\"](window),\n      isUnbounded: () => instance.unbounded,\n      isSurfaceActive: () => instance.root_[MATCHES](':active'),\n      isSurfaceDisabled: () => instance.disabled,\n      addClass: (className) => instance.root_.classList.add(className),\n      removeClass: (className) => instance.root_.classList.remove(className),\n      containsEventTarget: (target) => instance.root_.contains(target),\n      registerInteractionHandler: (evtType, handler) =>\n        instance.root_.addEventListener(evtType, handler, _util__WEBPACK_IMPORTED_MODULE_3__[\"applyPassive\"]()),\n      deregisterInteractionHandler: (evtType, handler) =>\n        instance.root_.removeEventListener(evtType, handler, _util__WEBPACK_IMPORTED_MODULE_3__[\"applyPassive\"]()),\n      registerDocumentInteractionHandler: (evtType, handler) =>\n        document.documentElement.addEventListener(evtType, handler, _util__WEBPACK_IMPORTED_MODULE_3__[\"applyPassive\"]()),\n      deregisterDocumentInteractionHandler: (evtType, handler) =>\n        document.documentElement.removeEventListener(evtType, handler, _util__WEBPACK_IMPORTED_MODULE_3__[\"applyPassive\"]()),\n      registerResizeHandler: (handler) => window.addEventListener('resize', handler),\n      deregisterResizeHandler: (handler) => window.removeEventListener('resize', handler),\n      updateCssVariable: (varName, value) => instance.root_.style.setProperty(varName, value),\n      computeBoundingRect: () => instance.root_.getBoundingClientRect(),\n      getWindowPageOffset: () => ({x: window.pageXOffset, y: window.pageYOffset}),\n    };\n  }\n\n  /** @return {boolean} */\n  get unbounded() {\n    return this.unbounded_;\n  }\n\n  /** @param {boolean} unbounded */\n  set unbounded(unbounded) {\n    this.unbounded_ = Boolean(unbounded);\n    this.setUnbounded_();\n  }\n\n  /**\n   * Closure Compiler throws an access control error when directly accessing a\n   * protected or private property inside a getter/setter, like unbounded above.\n   * By accessing the protected property inside a method, we solve that problem.\n   * That's why this function exists.\n   * @private\n   */\n  setUnbounded_() {\n    this.foundation_.setUnbounded(this.unbounded_);\n  }\n\n  activate() {\n    this.foundation_.activate();\n  }\n\n  deactivate() {\n    this.foundation_.deactivate();\n  }\n\n  layout() {\n    this.foundation_.layout();\n  }\n\n  /** @return {!MDCRippleFoundation} */\n  getDefaultFoundation() {\n    return new _foundation__WEBPACK_IMPORTED_MODULE_2__[\"default\"](MDCRipple.createAdapter(this));\n  }\n\n  initialSyncWithDOM() {\n    this.unbounded = 'mdcRippleIsUnbounded' in this.root_.dataset;\n  }\n}\n\n/**\n * See Material Design spec for more details on when to use ripples.\n * https://material.io/guidelines/motion/choreography.html#choreography-creation\n * @record\n */\nclass RippleCapableSurface {}\n\n/** @protected {!Element} */\nRippleCapableSurface.prototype.root_;\n\n/**\n * Whether or not the ripple bleeds out of the bounds of the element.\n * @type {boolean|undefined}\n */\nRippleCapableSurface.prototype.unbounded;\n\n/**\n * Whether or not the ripple is attached to a disabled component.\n * @type {boolean|undefined}\n */\nRippleCapableSurface.prototype.disabled;\n\n\n\n\n//# sourceURL=webpack:///./node_modules/@material/ripple/index.js?");

/***/ }),

/***/ "./node_modules/@material/ripple/util.js":
/*!***********************************************!*\
  !*** ./node_modules/@material/ripple/util.js ***!
  \***********************************************/
/*! exports provided: supportsCssVariables, applyPassive, getMatchesProperty, getNormalizedEventCoords */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"supportsCssVariables\", function() { return supportsCssVariables; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"applyPassive\", function() { return applyPassive; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getMatchesProperty\", function() { return getMatchesProperty; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getNormalizedEventCoords\", function() { return getNormalizedEventCoords; });\n/**\n * @license\n * Copyright 2016 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * Stores result from supportsCssVariables to avoid redundant processing to detect CSS custom variable support.\n * @private {boolean|undefined}\n */\nlet supportsCssVariables_;\n\n/**\n * Stores result from applyPassive to avoid redundant processing to detect passive event listener support.\n * @private {boolean|undefined}\n */\nlet supportsPassive_;\n\n/**\n * @param {!Window} windowObj\n * @return {boolean}\n */\nfunction detectEdgePseudoVarBug(windowObj) {\n  // Detect versions of Edge with buggy var() support\n  // See: https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/11495448/\n  const document = windowObj.document;\n  const node = document.createElement('div');\n  node.className = 'mdc-ripple-surface--test-edge-var-bug';\n  document.body.appendChild(node);\n\n  // The bug exists if ::before style ends up propagating to the parent element.\n  // Additionally, getComputedStyle returns null in iframes with display: \"none\" in Firefox,\n  // but Firefox is known to support CSS custom properties correctly.\n  // See: https://bugzilla.mozilla.org/show_bug.cgi?id=548397\n  const computedStyle = windowObj.getComputedStyle(node);\n  const hasPseudoVarBug = computedStyle !== null && computedStyle.borderTopStyle === 'solid';\n  node.remove();\n  return hasPseudoVarBug;\n}\n\n/**\n * @param {!Window} windowObj\n * @param {boolean=} forceRefresh\n * @return {boolean|undefined}\n */\n\nfunction supportsCssVariables(windowObj, forceRefresh = false) {\n  let supportsCssVariables = supportsCssVariables_;\n  if (typeof supportsCssVariables_ === 'boolean' && !forceRefresh) {\n    return supportsCssVariables;\n  }\n\n  const supportsFunctionPresent = windowObj.CSS && typeof windowObj.CSS.supports === 'function';\n  if (!supportsFunctionPresent) {\n    return;\n  }\n\n  const explicitlySupportsCssVars = windowObj.CSS.supports('--css-vars', 'yes');\n  // See: https://bugs.webkit.org/show_bug.cgi?id=154669\n  // See: README section on Safari\n  const weAreFeatureDetectingSafari10plus = (\n    windowObj.CSS.supports('(--css-vars: yes)') &&\n    windowObj.CSS.supports('color', '#00000000')\n  );\n\n  if (explicitlySupportsCssVars || weAreFeatureDetectingSafari10plus) {\n    supportsCssVariables = !detectEdgePseudoVarBug(windowObj);\n  } else {\n    supportsCssVariables = false;\n  }\n\n  if (!forceRefresh) {\n    supportsCssVariables_ = supportsCssVariables;\n  }\n  return supportsCssVariables;\n}\n\n//\n/**\n * Determine whether the current browser supports passive event listeners, and if so, use them.\n * @param {!Window=} globalObj\n * @param {boolean=} forceRefresh\n * @return {boolean|{passive: boolean}}\n */\nfunction applyPassive(globalObj = window, forceRefresh = false) {\n  if (supportsPassive_ === undefined || forceRefresh) {\n    let isSupported = false;\n    try {\n      globalObj.document.addEventListener('test', null, {get passive() {\n        isSupported = true;\n      }});\n    } catch (e) { }\n\n    supportsPassive_ = isSupported;\n  }\n\n  return supportsPassive_ ? {passive: true} : false;\n}\n\n/**\n * @param {!Object} HTMLElementPrototype\n * @return {!Array<string>}\n */\nfunction getMatchesProperty(HTMLElementPrototype) {\n  return [\n    'webkitMatchesSelector', 'msMatchesSelector', 'matches',\n  ].filter((p) => p in HTMLElementPrototype).pop();\n}\n\n/**\n * @param {!Event} ev\n * @param {{x: number, y: number}} pageOffset\n * @param {!ClientRect} clientRect\n * @return {{x: number, y: number}}\n */\nfunction getNormalizedEventCoords(ev, pageOffset, clientRect) {\n  const {x, y} = pageOffset;\n  const documentX = x + clientRect.left;\n  const documentY = y + clientRect.top;\n\n  let normalizedX;\n  let normalizedY;\n  // Determine touch point relative to the ripple container.\n  if (ev.type === 'touchstart') {\n    normalizedX = ev.changedTouches[0].pageX - documentX;\n    normalizedY = ev.changedTouches[0].pageY - documentY;\n  } else {\n    normalizedX = ev.pageX - documentX;\n    normalizedY = ev.pageY - documentY;\n  }\n\n  return {x: normalizedX, y: normalizedY};\n}\n\n\n\n\n//# sourceURL=webpack:///./node_modules/@material/ripple/util.js?");

/***/ }),

/***/ "./node_modules/css-loader/index.js!./node_modules/sass-loader/lib/loader.js?!./node_modules/@material/button/mdc-button.scss":
/*!************************************************************************************************************************************!*\
  !*** ./node_modules/css-loader!./node_modules/sass-loader/lib/loader.js??ref--5-2!./node_modules/@material/button/mdc-button.scss ***!
  \************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("exports = module.exports = __webpack_require__(/*! ../../css-loader/lib/css-base.js */ \"./node_modules/css-loader/lib/css-base.js\")(false);\n// imports\n\n\n// module\nexports.push([module.i, \"@keyframes mdc-ripple-fg-radius-in {\\n  from {\\n    animation-timing-function: cubic-bezier(0.4, 0, 0.2, 1);\\n    transform: translate(var(--mdc-ripple-fg-translate-start, 0)) scale(1); }\\n  to {\\n    transform: translate(var(--mdc-ripple-fg-translate-end, 0)) scale(var(--mdc-ripple-fg-scale, 1)); } }\\n\\n@keyframes mdc-ripple-fg-opacity-in {\\n  from {\\n    animation-timing-function: linear;\\n    opacity: 0; }\\n  to {\\n    opacity: var(--mdc-ripple-fg-opacity, 0); } }\\n\\n@keyframes mdc-ripple-fg-opacity-out {\\n  from {\\n    animation-timing-function: linear;\\n    opacity: var(--mdc-ripple-fg-opacity, 0); }\\n  to {\\n    opacity: 0; } }\\n\\n.mdc-ripple-surface--test-edge-var-bug {\\n  --mdc-ripple-surface-test-edge-var: 1px solid #000;\\n  visibility: hidden; }\\n  .mdc-ripple-surface--test-edge-var-bug::before {\\n    border: var(--mdc-ripple-surface-test-edge-var); }\\n\\n.mdc-button {\\n  font-family: Roboto, sans-serif;\\n  -moz-osx-font-smoothing: grayscale;\\n  -webkit-font-smoothing: antialiased;\\n  font-size: 0.875rem;\\n  line-height: 2.25rem;\\n  font-weight: 500;\\n  letter-spacing: 0.08929em;\\n  text-decoration: none;\\n  text-transform: uppercase;\\n  --mdc-ripple-fg-size: 0;\\n  --mdc-ripple-left: 0;\\n  --mdc-ripple-top: 0;\\n  --mdc-ripple-fg-scale: 1;\\n  --mdc-ripple-fg-translate-end: 0;\\n  --mdc-ripple-fg-translate-start: 0;\\n  -webkit-tap-highlight-color: rgba(0, 0, 0, 0);\\n  will-change: transform, opacity;\\n  padding: 0 8px 0 8px;\\n  display: inline-flex;\\n  position: relative;\\n  align-items: center;\\n  justify-content: center;\\n  box-sizing: border-box;\\n  min-width: 64px;\\n  height: 36px;\\n  border: none;\\n  outline: none;\\n  /* @alternate */\\n  line-height: inherit;\\n  user-select: none;\\n  -webkit-appearance: none;\\n  overflow: hidden;\\n  vertical-align: middle;\\n  border-radius: 2px; }\\n  .mdc-button::before, .mdc-button::after {\\n    position: absolute;\\n    border-radius: 50%;\\n    opacity: 0;\\n    pointer-events: none;\\n    content: \\\"\\\"; }\\n  .mdc-button::before {\\n    transition: opacity 15ms linear;\\n    z-index: 1; }\\n  .mdc-button.mdc-ripple-upgraded::before {\\n    transform: scale(var(--mdc-ripple-fg-scale, 1)); }\\n  .mdc-button.mdc-ripple-upgraded::after {\\n    top: 0;\\n    /* @noflip */\\n    left: 0;\\n    transform: scale(0);\\n    transform-origin: center center; }\\n  .mdc-button.mdc-ripple-upgraded--unbounded::after {\\n    top: var(--mdc-ripple-top, 0);\\n    /* @noflip */\\n    left: var(--mdc-ripple-left, 0); }\\n  .mdc-button.mdc-ripple-upgraded--foreground-activation::after {\\n    animation: 225ms mdc-ripple-fg-radius-in forwards, 75ms mdc-ripple-fg-opacity-in forwards; }\\n  .mdc-button.mdc-ripple-upgraded--foreground-deactivation::after {\\n    animation: 150ms mdc-ripple-fg-opacity-out;\\n    transform: translate(var(--mdc-ripple-fg-translate-end, 0)) scale(var(--mdc-ripple-fg-scale, 1)); }\\n  .mdc-button::before, .mdc-button::after {\\n    top: calc(50% - 100%);\\n    /* @noflip */\\n    left: calc(50% - 100%);\\n    width: 200%;\\n    height: 200%; }\\n  .mdc-button.mdc-ripple-upgraded::after {\\n    width: var(--mdc-ripple-fg-size, 100%);\\n    height: var(--mdc-ripple-fg-size, 100%); }\\n  .mdc-button::-moz-focus-inner {\\n    padding: 0;\\n    border: 0; }\\n  .mdc-button:active {\\n    outline: none; }\\n  .mdc-button:hover {\\n    cursor: pointer; }\\n  .mdc-button:disabled {\\n    background-color: transparent;\\n    color: rgba(0, 0, 0, 0.37);\\n    cursor: default;\\n    pointer-events: none; }\\n  .mdc-button:not(:disabled) {\\n    background-color: transparent; }\\n  .mdc-button:not(:disabled) {\\n    color: #6200ee;\\n    /* @alternate */\\n    color: var(--mdc-theme-primary, #6200ee); }\\n  .mdc-button::before, .mdc-button::after {\\n    background-color: #6200ee; }\\n    @supports not (-ms-ime-align: auto) {\\n      .mdc-button::before, .mdc-button::after {\\n        /* @alternate */\\n        background-color: var(--mdc-theme-primary, #6200ee); } }\\n  .mdc-button:hover::before {\\n    opacity: 0.04; }\\n  .mdc-button:not(.mdc-ripple-upgraded):focus::before, .mdc-button.mdc-ripple-upgraded--background-focused::before {\\n    transition-duration: 75ms;\\n    opacity: 0.12; }\\n  .mdc-button:not(.mdc-ripple-upgraded)::after {\\n    transition: opacity 150ms linear; }\\n  .mdc-button:not(.mdc-ripple-upgraded):active::after {\\n    transition-duration: 75ms;\\n    opacity: 0.16; }\\n  .mdc-button.mdc-ripple-upgraded {\\n    --mdc-ripple-fg-opacity: 0.16; }\\n  .mdc-button .mdc-button__icon {\\n    /* @noflip */\\n    margin-left: 0;\\n    /* @noflip */\\n    margin-right: 8px;\\n    display: inline-block;\\n    width: 18px;\\n    height: 18px;\\n    font-size: 18px;\\n    vertical-align: top; }\\n    [dir=\\\"rtl\\\"] .mdc-button .mdc-button__icon, .mdc-button .mdc-button__icon[dir=\\\"rtl\\\"] {\\n      /* @noflip */\\n      margin-left: 8px;\\n      /* @noflip */\\n      margin-right: 0; }\\n  .mdc-button svg.mdc-button__icon {\\n    fill: currentColor; }\\n\\n.mdc-button--raised .mdc-button__icon,\\n.mdc-button--unelevated .mdc-button__icon,\\n.mdc-button--outlined .mdc-button__icon {\\n  /* @noflip */\\n  margin-left: -4px;\\n  /* @noflip */\\n  margin-right: 8px; }\\n  [dir=\\\"rtl\\\"] .mdc-button--raised .mdc-button__icon, .mdc-button--raised .mdc-button__icon[dir=\\\"rtl\\\"], [dir=\\\"rtl\\\"]\\n  .mdc-button--unelevated .mdc-button__icon,\\n  .mdc-button--unelevated .mdc-button__icon[dir=\\\"rtl\\\"], [dir=\\\"rtl\\\"]\\n  .mdc-button--outlined .mdc-button__icon,\\n  .mdc-button--outlined .mdc-button__icon[dir=\\\"rtl\\\"] {\\n    /* @noflip */\\n    margin-left: 8px;\\n    /* @noflip */\\n    margin-right: -4px; }\\n\\n.mdc-button--raised,\\n.mdc-button--unelevated {\\n  padding: 0 16px 0 16px; }\\n  .mdc-button--raised:disabled,\\n  .mdc-button--unelevated:disabled {\\n    background-color: rgba(0, 0, 0, 0.12);\\n    color: rgba(0, 0, 0, 0.37); }\\n  .mdc-button--raised:not(:disabled),\\n  .mdc-button--unelevated:not(:disabled) {\\n    background-color: #6200ee; }\\n    @supports not (-ms-ime-align: auto) {\\n      .mdc-button--raised:not(:disabled),\\n      .mdc-button--unelevated:not(:disabled) {\\n        /* @alternate */\\n        background-color: var(--mdc-theme-primary, #6200ee); } }\\n  .mdc-button--raised:not(:disabled),\\n  .mdc-button--unelevated:not(:disabled) {\\n    color: #fff;\\n    /* @alternate */\\n    color: var(--mdc-theme-on-primary, #fff); }\\n  .mdc-button--raised::before, .mdc-button--raised::after,\\n  .mdc-button--unelevated::before,\\n  .mdc-button--unelevated::after {\\n    background-color: #fff; }\\n    @supports not (-ms-ime-align: auto) {\\n      .mdc-button--raised::before, .mdc-button--raised::after,\\n      .mdc-button--unelevated::before,\\n      .mdc-button--unelevated::after {\\n        /* @alternate */\\n        background-color: var(--mdc-theme-on-primary, #fff); } }\\n  .mdc-button--raised:hover::before,\\n  .mdc-button--unelevated:hover::before {\\n    opacity: 0.08; }\\n  .mdc-button--raised:not(.mdc-ripple-upgraded):focus::before, .mdc-button--raised.mdc-ripple-upgraded--background-focused::before,\\n  .mdc-button--unelevated:not(.mdc-ripple-upgraded):focus::before,\\n  .mdc-button--unelevated.mdc-ripple-upgraded--background-focused::before {\\n    transition-duration: 75ms;\\n    opacity: 0.24; }\\n  .mdc-button--raised:not(.mdc-ripple-upgraded)::after,\\n  .mdc-button--unelevated:not(.mdc-ripple-upgraded)::after {\\n    transition: opacity 150ms linear; }\\n  .mdc-button--raised:not(.mdc-ripple-upgraded):active::after,\\n  .mdc-button--unelevated:not(.mdc-ripple-upgraded):active::after {\\n    transition-duration: 75ms;\\n    opacity: 0.32; }\\n  .mdc-button--raised.mdc-ripple-upgraded,\\n  .mdc-button--unelevated.mdc-ripple-upgraded {\\n    --mdc-ripple-fg-opacity: 0.32; }\\n\\n.mdc-button--raised {\\n  box-shadow: 0px 3px 1px -2px rgba(0, 0, 0, 0.2), 0px 2px 2px 0px rgba(0, 0, 0, 0.14), 0px 1px 5px 0px rgba(0, 0, 0, 0.12);\\n  transition: box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1); }\\n  .mdc-button--raised:hover, .mdc-button--raised:focus {\\n    box-shadow: 0px 2px 4px -1px rgba(0, 0, 0, 0.2), 0px 4px 5px 0px rgba(0, 0, 0, 0.14), 0px 1px 10px 0px rgba(0, 0, 0, 0.12); }\\n  .mdc-button--raised:active {\\n    box-shadow: 0px 5px 5px -3px rgba(0, 0, 0, 0.2), 0px 8px 10px 1px rgba(0, 0, 0, 0.14), 0px 3px 14px 2px rgba(0, 0, 0, 0.12); }\\n  .mdc-button--raised:disabled {\\n    box-shadow: 0px 0px 0px 0px rgba(0, 0, 0, 0.2), 0px 0px 0px 0px rgba(0, 0, 0, 0.14), 0px 0px 0px 0px rgba(0, 0, 0, 0.12); }\\n\\n.mdc-button--outlined {\\n  border-style: solid;\\n  padding: 0 14px 0 14px;\\n  border-width: 2px;\\n  line-height: 32px; }\\n  .mdc-button--outlined:disabled {\\n    border-color: rgba(0, 0, 0, 0.37); }\\n  .mdc-button--outlined.mdc-button--dense {\\n    line-height: 27px; }\\n  .mdc-button--outlined:not(:disabled) {\\n    border-color: #6200ee;\\n    /* @alternate */\\n    border-color: var(--mdc-theme-primary, #6200ee); }\\n\\n.mdc-button--dense {\\n  height: 32px;\\n  font-size: .8125rem;\\n  line-height: 32px; }\\n\", \"\"]);\n\n// exports\n\n\n//# sourceURL=webpack:///./node_modules/@material/button/mdc-button.scss?./node_modules/css-loader!./node_modules/sass-loader/lib/loader.js??ref--5-2");

/***/ }),

/***/ "./node_modules/css-loader/index.js!./node_modules/sass-loader/lib/loader.js?!./src/icon/index.css":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/css-loader!./node_modules/sass-loader/lib/loader.js??ref--5-2!./src/icon/index.css ***!
  \*********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("exports = module.exports = __webpack_require__(/*! ../../node_modules/css-loader/lib/css-base.js */ \"./node_modules/css-loader/lib/css-base.js\")(false);\n// imports\nexports.push([module.i, \"@import url(https://fonts.googleapis.com/css?family=Material+Icons);\", \"\"]);\n\n// module\nexports.push([module.i, \".material-icons {\\n  font-family: 'Material Icons';\\n  font-weight: normal;\\n  font-style: normal;\\n  font-size: 24px;\\n  /* Preferred icon size */\\n  display: inline-block;\\n  line-height: 1;\\n  text-transform: none;\\n  letter-spacing: normal;\\n  word-wrap: normal;\\n  white-space: nowrap;\\n  direction: ltr;\\n  /* Support for all WebKit browsers. */\\n  -webkit-font-smoothing: antialiased;\\n  /* Support for Safari and Chrome. */\\n  text-rendering: optimizeLegibility;\\n  /* Support for Firefox. */\\n  -moz-osx-font-smoothing: grayscale;\\n  /* Support for IE. */\\n  font-feature-settings: 'liga'; }\\n\\n/* Rules for sizing the icon. */\\n.material-icons.md-18 {\\n  font-size: 18px; }\\n\\n.material-icons.md-24 {\\n  font-size: 24px; }\\n\\n.material-icons.md-36 {\\n  font-size: 36px; }\\n\\n.material-icons.md-48 {\\n  font-size: 48px; }\\n\\n/* Rules for using icons as black on a light background. */\\n.material-icons.md-dark {\\n  color: rgba(0, 0, 0, 0.54); }\\n\\n.material-icons.md-dark.md-inactive {\\n  color: rgba(0, 0, 0, 0.26); }\\n\\n/* Rules for using icons as white on a dark background. */\\n.material-icons.md-light {\\n  color: white; }\\n\\n.material-icons.md-light.md-inactive {\\n  color: rgba(255, 255, 255, 0.3); }\\n\", \"\"]);\n\n// exports\n\n\n//# sourceURL=webpack:///./src/icon/index.css?./node_modules/css-loader!./node_modules/sass-loader/lib/loader.js??ref--5-2");

/***/ }),

/***/ "./node_modules/css-loader/lib/css-base.js":
/*!*************************************************!*\
  !*** ./node_modules/css-loader/lib/css-base.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n// css base code, injected by the css-loader\nmodule.exports = function(useSourceMap) {\n\tvar list = [];\n\n\t// return the list of modules as css string\n\tlist.toString = function toString() {\n\t\treturn this.map(function (item) {\n\t\t\tvar content = cssWithMappingToString(item, useSourceMap);\n\t\t\tif(item[2]) {\n\t\t\t\treturn \"@media \" + item[2] + \"{\" + content + \"}\";\n\t\t\t} else {\n\t\t\t\treturn content;\n\t\t\t}\n\t\t}).join(\"\");\n\t};\n\n\t// import a list of modules into the list\n\tlist.i = function(modules, mediaQuery) {\n\t\tif(typeof modules === \"string\")\n\t\t\tmodules = [[null, modules, \"\"]];\n\t\tvar alreadyImportedModules = {};\n\t\tfor(var i = 0; i < this.length; i++) {\n\t\t\tvar id = this[i][0];\n\t\t\tif(typeof id === \"number\")\n\t\t\t\talreadyImportedModules[id] = true;\n\t\t}\n\t\tfor(i = 0; i < modules.length; i++) {\n\t\t\tvar item = modules[i];\n\t\t\t// skip already imported module\n\t\t\t// this implementation is not 100% perfect for weird media query combinations\n\t\t\t//  when a module is imported multiple times with different media queries.\n\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\n\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\n\t\t\t\tif(mediaQuery && !item[2]) {\n\t\t\t\t\titem[2] = mediaQuery;\n\t\t\t\t} else if(mediaQuery) {\n\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\n\t\t\t\t}\n\t\t\t\tlist.push(item);\n\t\t\t}\n\t\t}\n\t};\n\treturn list;\n};\n\nfunction cssWithMappingToString(item, useSourceMap) {\n\tvar content = item[1] || '';\n\tvar cssMapping = item[3];\n\tif (!cssMapping) {\n\t\treturn content;\n\t}\n\n\tif (useSourceMap && typeof btoa === 'function') {\n\t\tvar sourceMapping = toComment(cssMapping);\n\t\tvar sourceURLs = cssMapping.sources.map(function (source) {\n\t\t\treturn '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */'\n\t\t});\n\n\t\treturn [content].concat(sourceURLs).concat([sourceMapping]).join('\\n');\n\t}\n\n\treturn [content].join('\\n');\n}\n\n// Adapted from convert-source-map (MIT)\nfunction toComment(sourceMap) {\n\t// eslint-disable-next-line no-undef\n\tvar base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));\n\tvar data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;\n\n\treturn '/*# ' + data + ' */';\n}\n\n\n//# sourceURL=webpack:///./node_modules/css-loader/lib/css-base.js?");

/***/ }),

/***/ "./node_modules/imba/imba.imba":
/*!*************************************!*\
  !*** ./node_modules/imba/imba.imba ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! ./src/imba/index.imba */ \"./node_modules/imba/src/imba/index.imba\");\n\n\n//# sourceURL=webpack:///./node_modules/imba/imba.imba?");

/***/ }),

/***/ "./node_modules/imba/src/imba/dom/event-manager.imba":
/*!***********************************************************!*\
  !*** ./node_modules/imba/src/imba/dom/event-manager.imba ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };\nvar Imba = __webpack_require__(/*! ../imba */ \"./node_modules/imba/src/imba/imba.imba\");\n__webpack_require__(/*! ./pointer */ \"./node_modules/imba/src/imba/dom/pointer.imba\");\n\nvar native$ = [\n\t'keydown','keyup','keypress',\n\t'textInput','input','change','submit',\n\t'focusin','focusout','focus','blur',\n\t'contextmenu','selectstart','dblclick',\n\t'mousewheel','wheel','scroll',\n\t'beforecopy','copy','beforepaste','paste','beforecut','cut',\n\t'dragstart','drag','dragend','dragenter','dragover','dragleave','dragexit','drop',\n\t'mouseup','mousedown','mouseenter','mouseleave','mouseout','mouseover','mousemove'\n];\n\n/*\n\nManager for listening to and delegating events in Imba. A single instance\nis always created by Imba (as `Imba.Events`), which handles and delegates all\nevents at the very root of the document. Imba does not capture all events\nby default, so if you want to make sure exotic or custom DOMEvents are delegated\nin Imba you will need to register them in `Imba.Events.register(myCustomEventName)`\n\n@iname manager\n\n*/\n\nImba.EventManager = function EventManager(node,pars){\n\tvar self = this;\n\tif(!pars||pars.constructor !== Object) pars = {};\n\tvar events = pars.events !== undefined ? pars.events : [];\n\tself._shimFocusEvents = true && window.netscape && node.onfocusin === undefined;\n\tself.setRoot(node);\n\tself.setListeners([]);\n\tself.setDelegators({});\n\tself.setDelegator(function(e) {\n\t\tself.delegate(e);\n\t\treturn true;\n\t});\n\t\n\tfor (let i = 0, items = iter$(events), len = items.length; i < len; i++) {\n\t\tself.register(items[i]);\n\t};\n\t\n\treturn self;\n};\n\nImba.EventManager.prototype.root = function(v){ return this._root; }\nImba.EventManager.prototype.setRoot = function(v){ this._root = v; return this; };\nImba.EventManager.prototype.count = function(v){ return this._count; }\nImba.EventManager.prototype.setCount = function(v){ this._count = v; return this; };\nImba.EventManager.prototype.__enabled = {'default': false,watch: 'enabledDidSet',name: 'enabled'};\nImba.EventManager.prototype.enabled = function(v){ return this._enabled; }\nImba.EventManager.prototype.setEnabled = function(v){\n\tvar a = this.enabled();\n\tif(v != a) { this._enabled = v; }\n\tif(v != a) { this.enabledDidSet && this.enabledDidSet(v,a,this.__enabled) }\n\treturn this;\n}\nImba.EventManager.prototype._enabled = false;\nImba.EventManager.prototype.listeners = function(v){ return this._listeners; }\nImba.EventManager.prototype.setListeners = function(v){ this._listeners = v; return this; };\nImba.EventManager.prototype.delegators = function(v){ return this._delegators; }\nImba.EventManager.prototype.setDelegators = function(v){ this._delegators = v; return this; };\nImba.EventManager.prototype.delegator = function(v){ return this._delegator; }\nImba.EventManager.prototype.setDelegator = function(v){ this._delegator = v; return this; };\n\nvar initialBind = [];\n\nImba.EventManager.prototype.enabledDidSet = function (bool){\n\tbool ? this.onenable() : this.ondisable();\n\treturn this;\n};\n\nImba.EventManager.bind = function (name){\n\tif (Imba.Events) {\n\t\treturn Imba.Events.autoregister(name);\n\t} else if (initialBind.indexOf(name) == -1 && native$.indexOf(name) >= 0) {\n\t\treturn initialBind.push(name);\n\t};\n};\n\nImba.EventManager.activate = function (){\n\tvar Imba_;\n\tif (Imba.Events) { return Imba.Events };\n\tif (false) {};\n\t\n\tImba.POINTER || (Imba.POINTER = new Imba.Pointer());\n\tImba.Events = new Imba.EventManager(Imba.document(),{events: []});\n\t\n\tvar hasTouchEvents = window && window.ontouchstart !== undefined;\n\t\n\tif (hasTouchEvents) {\n\t\tImba.Events.listen('touchstart',function(e) {\n\t\t\treturn Imba.Touch.ontouchstart(e);\n\t\t});\n\t\t\n\t\tImba.Events.listen('touchmove',function(e) {\n\t\t\treturn Imba.Touch.ontouchmove(e);\n\t\t});\n\t\t\n\t\tImba.Events.listen('touchend',function(e) {\n\t\t\treturn Imba.Touch.ontouchend(e);\n\t\t});\n\t\t\n\t\tImba.Events.listen('touchcancel',function(e) {\n\t\t\treturn Imba.Touch.ontouchcancel(e);\n\t\t});\n\t};\n\t\n\tImba.Events.register('click',function(e) {\n\t\t// Only for main mousebutton, no?\n\t\tif ((e.timeStamp - Imba.Touch.LastTimestamp) > Imba.Touch.TapTimeout) {\n\t\t\te._imbaSimulatedTap = true;\n\t\t\tvar tap = new Imba.Event(e);\n\t\t\ttap.setType('tap');\n\t\t\ttap.process();\n\t\t\tif (tap._responder) {\n\t\t\t\treturn e.preventDefault();\n\t\t\t};\n\t\t};\n\t\t// delegate the real click event\n\t\treturn Imba.Events.delegate(e);\n\t});\n\t\n\tImba.Events.listen('mousedown',function(e) {\n\t\tif ((e.timeStamp - Imba.Touch.LastTimestamp) > Imba.Touch.TapTimeout) {\n\t\t\tif (Imba.POINTER) { return Imba.POINTER.update(e).process() };\n\t\t};\n\t});\n\t\n\tImba.Events.listen('mouseup',function(e) {\n\t\tif ((e.timeStamp - Imba.Touch.LastTimestamp) > Imba.Touch.TapTimeout) {\n\t\t\tif (Imba.POINTER) { return Imba.POINTER.update(e).process() };\n\t\t};\n\t});\n\t\n\tImba.Events.register(['mousedown','mouseup']);\n\tImba.Events.register(initialBind);\n\tImba.Events.setEnabled(true);\n\treturn Imba.Events;\n};\n\n\n/*\n\n\tTell the current EventManager to intercept and handle event of a certain name.\n\tBy default, Imba.Events will register interceptors for: *keydown*, *keyup*, \n\t*keypress*, *textInput*, *input*, *change*, *submit*, *focusin*, *focusout*, \n\t*blur*, *contextmenu*, *dblclick*, *mousewheel*, *wheel*\n\n\t*/\n\nImba.EventManager.prototype.register = function (name,handler){\n\tif(handler === undefined) handler = true;\n\tif (name instanceof Array) {\n\t\tfor (let i = 0, items = iter$(name), len = items.length; i < len; i++) {\n\t\t\tthis.register(items[i],handler);\n\t\t};\n\t\treturn this;\n\t};\n\t\n\tif (this.delegators()[name]) { return this };\n\t\n\t// console.log(\"register for event {name}\")\n\tvar fn = this.delegators()[name] = (handler instanceof Function) ? handler : this.delegator();\n\tif (this.enabled()) { return this.root().addEventListener(name,fn,true) };\n};\n\nImba.EventManager.prototype.autoregister = function (name){\n\tif (native$.indexOf(name) == -1) { return this };\n\treturn this.register(name);\n};\n\nImba.EventManager.prototype.listen = function (name,handler,capture){\n\tif(capture === undefined) capture = true;\n\tthis.listeners().push([name,handler,capture]);\n\tif (this.enabled()) { this.root().addEventListener(name,handler,capture) };\n\treturn this;\n};\n\nImba.EventManager.prototype.delegate = function (e){\n\tvar event = Imba.Event.wrap(e);\n\tevent.process();\n\tif (this._shimFocusEvents) {\n\t\tif (e.type == 'focus') {\n\t\t\tImba.Event.wrap(e).setType('focusin').process();\n\t\t} else if (e.type == 'blur') {\n\t\t\tImba.Event.wrap(e).setType('focusout').process();\n\t\t};\n\t};\n\treturn this;\n};\n\n/*\n\n\tCreate a new Imba.Event\n\n\t*/\n\nImba.EventManager.prototype.create = function (type,target,pars){\n\tif(!pars||pars.constructor !== Object) pars = {};\n\tvar data = pars.data !== undefined ? pars.data : null;\n\tvar source = pars.source !== undefined ? pars.source : null;\n\tvar event = Imba.Event.wrap({type: type,target: target});\n\tif (data) { (event.setData(data),data) };\n\tif (source) { (event.setSource(source),source) };\n\treturn event;\n};\n\n/*\n\n\tTrigger / process an Imba.Event.\n\n\t*/\n\nImba.EventManager.prototype.trigger = function (){\n\treturn this.create.apply(this,arguments).process();\n};\n\nImba.EventManager.prototype.onenable = function (){\n\tfor (let o = this.delegators(), handler, i = 0, keys = Object.keys(o), l = keys.length, name; i < l; i++){\n\t\tname = keys[i];handler = o[name];this.root().addEventListener(name,handler,true);\n\t};\n\t\n\tfor (let i = 0, items = iter$(this.listeners()), len = items.length, item; i < len; i++) {\n\t\titem = items[i];\n\t\tthis.root().addEventListener(item[0],item[1],item[2]);\n\t};\n\t\n\twindow.addEventListener('hashchange',Imba.commit);\n\twindow.addEventListener('popstate',Imba.commit);\n\treturn this;\n};\n\nImba.EventManager.prototype.ondisable = function (){\n\tfor (let o = this.delegators(), handler, i = 0, keys = Object.keys(o), l = keys.length, name; i < l; i++){\n\t\tname = keys[i];handler = o[name];this.root().removeEventListener(name,handler,true);\n\t};\n\t\n\tfor (let i = 0, items = iter$(this.listeners()), len = items.length, item; i < len; i++) {\n\t\titem = items[i];\n\t\tthis.root().removeEventListener(item[0],item[1],item[2]);\n\t};\n\t\n\twindow.removeEventListener('hashchange',Imba.commit);\n\twindow.removeEventListener('popstate',Imba.commit);\n\treturn this;\n};\n\n\n//# sourceURL=webpack:///./node_modules/imba/src/imba/dom/event-manager.imba?");

/***/ }),

/***/ "./node_modules/imba/src/imba/dom/event.imba":
/*!***************************************************!*\
  !*** ./node_modules/imba/src/imba/dom/event.imba ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };\nvar Imba = __webpack_require__(/*! ../imba */ \"./node_modules/imba/src/imba/imba.imba\");\n\nvar keyCodes = {\n\tesc: 27,\n\ttab: 9,\n\tenter: 13,\n\tspace: 32,\n\tup: 38,\n\tdown: 40\n};\n\nvar el = Imba.Tag.prototype;\nel.stopModifier = function (e){\n\treturn e.stop() || true;\n};\nel.preventModifier = function (e){\n\treturn e.prevent() || true;\n};\nel.silenceModifier = function (e){\n\treturn e.silence() || true;\n};\nel.bubbleModifier = function (e){\n\treturn e.bubble(true) || true;\n};\nel.ctrlModifier = function (e){\n\treturn e.event().ctrlKey == true;\n};\nel.altModifier = function (e){\n\treturn e.event().altKey == true;\n};\nel.shiftModifier = function (e){\n\treturn e.event().shiftKey == true;\n};\nel.metaModifier = function (e){\n\treturn e.event().metaKey == true;\n};\nel.keyModifier = function (key,e){\n\treturn e.keyCode() ? ((e.keyCode() == key)) : true;\n};\nel.delModifier = function (e){\n\treturn e.keyCode() ? ((e.keyCode() == 8 || e.keyCode() == 46)) : true;\n};\nel.selfModifier = function (e){\n\treturn e.event().target == this._dom;\n};\nel.leftModifier = function (e){\n\treturn (e.button() != undefined) ? ((e.button() === 0)) : el.keyModifier(37,e);\n};\nel.rightModifier = function (e){\n\treturn (e.button() != undefined) ? ((e.button() === 2)) : el.keyModifier(39,e);\n};\nel.middleModifier = function (e){\n\treturn (e.button() != undefined) ? ((e.button() === 1)) : true;\n};\n\nel.getHandler = function (str,event){\n\tif (this[str]) { return this };\n};\n\n/*\nImba handles all events in the dom through a single manager,\nlistening at the root of your document. If Imba finds a tag\nthat listens to a certain event, the event will be wrapped \nin an `Imba.Event`, which normalizes some of the quirks and \nbrowser differences.\n\n@iname event\n*/\n\nImba.Event = function Event(e){\n\tthis.setEvent(e);\n\tthis._bubble = true;\n};\n\n/* reference to the native event */\n\nImba.Event.prototype.event = function(v){ return this._event; }\nImba.Event.prototype.setEvent = function(v){ this._event = v; return this; };\n\nImba.Event.prototype.prefix = function(v){ return this._prefix; }\nImba.Event.prototype.setPrefix = function(v){ this._prefix = v; return this; };\n\nImba.Event.prototype.source = function(v){ return this._source; }\nImba.Event.prototype.setSource = function(v){ this._source = v; return this; };\n\nImba.Event.prototype.data = function(v){ return this._data; }\nImba.Event.prototype.setData = function(v){ this._data = v; return this; };\n\nImba.Event.prototype.responder = function(v){ return this._responder; }\nImba.Event.prototype.setResponder = function(v){ this._responder = v; return this; };\n\nImba.Event.wrap = function (e){\n\treturn new this(e);\n};\n\nImba.Event.prototype.setType = function (type){\n\tthis._type = type;\n\tthis;\n\treturn this;\n};\n\n/*\n\t@return {String} The name of the event (case-insensitive)\n\t*/\n\nImba.Event.prototype.type = function (){\n\treturn this._type || this.event().type;\n};\nImba.Event.prototype.native = function (){\n\treturn this._event;\n};\n\nImba.Event.prototype.name = function (){\n\treturn this._name || (this._name = this.type().toLowerCase().replace(/\\:/g,''));\n};\n\n// mimc getset\nImba.Event.prototype.bubble = function (v){\n\tif (v != undefined) {\n\t\tthis.setBubble(v);\n\t\treturn this;\n\t};\n\treturn this._bubble;\n};\n\nImba.Event.prototype.setBubble = function (v){\n\tthis._bubble = v;\n\treturn this;\n\treturn this;\n};\n\n/*\n\tPrevents further propagation of the current event.\n\t@return {self}\n\t*/\n\nImba.Event.prototype.stop = function (){\n\tthis.setBubble(false);\n\treturn this;\n};\n\nImba.Event.prototype.stopPropagation = function (){\n\treturn this.stop();\n};\nImba.Event.prototype.halt = function (){\n\treturn this.stop();\n};\n\n// migrate from cancel to prevent\nImba.Event.prototype.prevent = function (){\n\tif (this.event().preventDefault) {\n\t\tthis.event().preventDefault();\n\t} else {\n\t\tthis.event().defaultPrevented = true;\n\t};\n\tthis.defaultPrevented = true;\n\treturn this;\n};\n\nImba.Event.prototype.preventDefault = function (){\n\tconsole.warn(\"Event#preventDefault is deprecated - use Event#prevent\");\n\treturn this.prevent();\n};\n\n/*\n\tIndicates whether or not event.cancel has been called.\n\n\t@return {Boolean}\n\t*/\n\nImba.Event.prototype.isPrevented = function (){\n\treturn this.event() && this.event().defaultPrevented || this._cancel;\n};\n\n/*\n\tCancel the event (if cancelable). In the case of native events it\n\twill call `preventDefault` on the wrapped event object.\n\t@return {self}\n\t*/\n\nImba.Event.prototype.cancel = function (){\n\tconsole.warn(\"Event#cancel is deprecated - use Event#prevent\");\n\treturn this.prevent();\n};\n\nImba.Event.prototype.silence = function (){\n\tthis._silenced = true;\n\treturn this;\n};\n\nImba.Event.prototype.isSilenced = function (){\n\treturn !!this._silenced;\n};\n\n/*\n\tA reference to the initial target of the event.\n\t*/\n\nImba.Event.prototype.target = function (){\n\treturn Imba.getTagForDom(this.event()._target || this.event().target);\n};\n\n/*\n\tA reference to the object responding to the event.\n\t*/\n\nImba.Event.prototype.responder = function (){\n\treturn this._responder;\n};\n\n/*\n\tRedirect the event to new target\n\t*/\n\nImba.Event.prototype.redirect = function (node){\n\tthis._redirect = node;\n\treturn this;\n};\n\nImba.Event.prototype.processHandlers = function (node,handlers){\n\tlet i = 1;\n\tlet l = handlers.length;\n\tlet bubble = this._bubble;\n\tlet state = handlers.state || (handlers.state = {});\n\tlet result;\n\t\n\tif (bubble) {\n\t\tthis._bubble = 1;\n\t};\n\t\n\twhile (i < l){\n\t\tlet isMod = false;\n\t\tlet handler = handlers[i++];\n\t\tlet params = null;\n\t\tlet context = node;\n\t\t\n\t\tif (handler instanceof Array) {\n\t\t\tparams = handler.slice(1);\n\t\t\thandler = handler[0];\n\t\t};\n\t\t\n\t\tif (typeof handler == 'string') {\n\t\t\tif (keyCodes[handler]) {\n\t\t\t\tparams = [keyCodes[handler]];\n\t\t\t\thandler = 'key';\n\t\t\t};\n\t\t\t\n\t\t\tlet mod = handler + 'Modifier';\n\t\t\t\n\t\t\tif (node[mod]) {\n\t\t\t\tisMod = true;\n\t\t\t\tparams = (params || []).concat([this,state]);\n\t\t\t\thandler = node[mod];\n\t\t\t};\n\t\t};\n\t\t\n\t\t// if it is still a string - call getHandler on\n\t\t// ancestor of node to see if we get a handler for this name\n\t\tif (typeof handler == 'string') {\n\t\t\tlet el = node;\n\t\t\tlet fn = null;\n\t\t\tlet ctx = state.context;\n\t\t\t\n\t\t\tif (ctx) {\n\t\t\t\tif (ctx.getHandler instanceof Function) {\n\t\t\t\t\tctx = ctx.getHandler(handler,this);\n\t\t\t\t};\n\t\t\t\t\n\t\t\t\tif (ctx[handler] instanceof Function) {\n\t\t\t\t\thandler = fn = ctx[handler];\n\t\t\t\t\tcontext = ctx;\n\t\t\t\t};\n\t\t\t};\n\t\t\t\n\t\t\tif (!fn) {\n\t\t\t\tconsole.warn((\"event \" + this.type() + \": could not find '\" + handler + \"' in context\"),ctx);\n\t\t\t};\n\t\t\t\n\t\t\t// while el and (!fn or !(fn isa Function))\n\t\t\t// \tif fn = el.getHandler(handler)\n\t\t\t// \t\tif fn[handler] isa Function\n\t\t\t// \t\t\thandler = fn[handler]\n\t\t\t// \t\t\tcontext = fn\n\t\t\t// \t\telif fn isa Function\n\t\t\t// \t\t\thandler = fn\n\t\t\t// \t\t\tcontext = el\n\t\t\t// \telse\n\t\t\t// \t\tel = el.parent\n\t\t};\n\t\t\n\t\tif (handler instanceof Function) {\n\t\t\t// what if we actually call stop inside function?\n\t\t\t// do we still want to continue the chain?\n\t\t\tlet res = handler.apply(context,params || [this]);\n\t\t\t\n\t\t\tif (!isMod) {\n\t\t\t\tthis._responder || (this._responder = node);\n\t\t\t};\n\t\t\t\n\t\t\tif (res == false) {\n\t\t\t\t// console.log \"returned false - breaking\"\n\t\t\t\tbreak;\n\t\t\t};\n\t\t\t\n\t\t\tif (res && !this._silenced && (res.then instanceof Function)) {\n\t\t\t\tres.then(Imba.commit);\n\t\t\t};\n\t\t};\n\t};\n\t\n\t// if we havent stopped or dealt with bubble while handling\n\tif (this._bubble === 1) {\n\t\tthis._bubble = bubble;\n\t};\n\t\n\treturn null;\n};\n\nImba.Event.prototype.process = function (){\n\tvar name = this.name();\n\tvar meth = (\"on\" + (this._prefix || '') + name);\n\tvar args = null;\n\tvar domtarget = this.event()._target || this.event().target;\n\tvar domnode = domtarget._responder || domtarget;\n\t// @todo need to stop infinite redirect-rules here\n\tvar result;\n\tvar handlers;\n\t\n\twhile (domnode){\n\t\tthis._redirect = null;\n\t\tlet node = domnode._dom ? domnode : domnode._tag;\n\t\t\n\t\tif (node) {\n\t\t\tif (handlers = node._on_) {\n\t\t\t\tfor (let i = 0, items = iter$(handlers), len = items.length, handler; i < len; i++) {\n\t\t\t\t\thandler = items[i];\n\t\t\t\t\tif (!handler) { continue; };\n\t\t\t\t\tlet hname = handler[0];\n\t\t\t\t\tif (name == handler[0] && this.bubble()) {\n\t\t\t\t\t\tthis.processHandlers(node,handler);\n\t\t\t\t\t};\n\t\t\t\t};\n\t\t\t\tif (!(this.bubble())) { break; };\n\t\t\t};\n\t\t\t\n\t\t\tif (this.bubble() && (node[meth] instanceof Function)) {\n\t\t\t\tthis._responder || (this._responder = node);\n\t\t\t\tthis._silenced = false;\n\t\t\t\tresult = args ? node[meth].apply(node,args) : node[meth](this,this.data());\n\t\t\t};\n\t\t\t\n\t\t\tif (node.onevent) {\n\t\t\t\tnode.onevent(this);\n\t\t\t};\n\t\t};\n\t\t\n\t\t// add node.nextEventResponder as a separate method here?\n\t\tif (!(this.bubble() && (domnode = (this._redirect || (node ? node.parent() : domnode.parentNode))))) {\n\t\t\tbreak;\n\t\t};\n\t};\n\t\n\tthis.processed();\n\t\n\t// if a handler returns a promise, notify schedulers\n\t// about this after promise has finished processing\n\tif (result && (result.then instanceof Function)) {\n\t\tresult.then(this.processed.bind(this));\n\t};\n\treturn this;\n};\n\n\nImba.Event.prototype.processed = function (){\n\tif (!this._silenced && this._responder) {\n\t\tImba.emit(Imba,'event',[this]);\n\t\tImba.commit(this.event());\n\t};\n\treturn this;\n};\n\n/*\n\tReturn the x/left coordinate of the mouse / pointer for this event\n\t@return {Number} x coordinate of mouse / pointer for event\n\t*/\n\nImba.Event.prototype.x = function (){\n\treturn this.native().x;\n};\n\n/*\n\tReturn the y/top coordinate of the mouse / pointer for this event\n\t@return {Number} y coordinate of mouse / pointer for event\n\t*/\n\nImba.Event.prototype.y = function (){\n\treturn this.native().y;\n};\n\nImba.Event.prototype.button = function (){\n\treturn this.native().button;\n};\nImba.Event.prototype.keyCode = function (){\n\treturn this.native().keyCode;\n};\nImba.Event.prototype.ctrl = function (){\n\treturn this.native().ctrlKey;\n};\nImba.Event.prototype.alt = function (){\n\treturn this.native().altKey;\n};\nImba.Event.prototype.shift = function (){\n\treturn this.native().shiftKey;\n};\nImba.Event.prototype.meta = function (){\n\treturn this.native().metaKey;\n};\nImba.Event.prototype.key = function (){\n\treturn this.native().key;\n};\n\n/*\n\tReturns a Number representing a system and implementation\n\tdependent numeric code identifying the unmodified value of the\n\tpressed key; this is usually the same as keyCode.\n\n\tFor mouse-events, the returned value indicates which button was\n\tpressed on the mouse to trigger the event.\n\n\t@return {Number}\n\t*/\n\nImba.Event.prototype.which = function (){\n\treturn this.event().which;\n};\n\n\n\n//# sourceURL=webpack:///./node_modules/imba/src/imba/dom/event.imba?");

/***/ }),

/***/ "./node_modules/imba/src/imba/dom/html.imba":
/*!**************************************************!*\
  !*** ./node_modules/imba/src/imba/dom/html.imba ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };\nvar Imba = __webpack_require__(/*! ../imba */ \"./node_modules/imba/src/imba/imba.imba\");\n\nImba.defineTag('fragment', 'element', function(tag){\n\ttag.createNode = function (){\n\t\treturn Imba.document().createDocumentFragment();\n\t};\n});\n\nImba.extendTag('html', function(tag){\n\ttag.prototype.parent = function (){\n\t\treturn null;\n\t};\n});\n\nImba.extendTag('canvas', function(tag){\n\ttag.prototype.context = function (type){\n\t\tif(type === undefined) type = '2d';\n\t\treturn this.dom().getContext(type);\n\t};\n});\n\nfunction DataProxy(node,path,args){\n\tthis._node = node;\n\tthis._path = path;\n\tthis._args = args;\n\tif (this._args) { this._setter = Imba.toSetter(this._path) };\n};\n\nDataProxy.bind = function (receiver,data,path,args){\n\tlet proxy = receiver._data || (receiver._data = new this(receiver,path,args));\n\tproxy.bind(data,path,args);\n\treturn receiver;\n};\n\nDataProxy.prototype.bind = function (data,key,args){\n\tif (data != this._data) {\n\t\tthis._data = data;\n\t};\n\treturn this;\n};\n\nDataProxy.prototype.getFormValue = function (){\n\treturn this._setter ? this._data[this._path]() : this._data[this._path];\n};\n\nDataProxy.prototype.setFormValue = function (value){\n\treturn this._setter ? this._data[this._setter](value) : ((this._data[this._path] = value));\n};\n\n\nvar isArray = function(val) {\n\treturn val && val.splice && val.sort;\n};\n\nvar isSimilarArray = function(a,b) {\n\tlet l = a.length,i = 0;\n\tif (l != b.length) { return false };\n\twhile (i++ < l){\n\t\tif (a[i] != b[i]) { return false };\n\t};\n\treturn true;\n};\n\nImba.extendTag('input', function(tag){\n\ttag.prototype.lazy = function(v){ return this._lazy; }\n\ttag.prototype.setLazy = function(v){ this._lazy = v; return this; };\n\t\n\ttag.prototype.bindData = function (target,path,args){\n\t\tDataProxy.bind(this,target,path,args);\n\t\treturn this;\n\t};\n\t\n\ttag.prototype.checked = function (){\n\t\treturn this._dom.checked;\n\t};\n\t\n\ttag.prototype.setChecked = function (value){\n\t\tif (!!value != this._dom.checked) {\n\t\t\tthis._dom.checked = !!value;\n\t\t};\n\t\treturn this;\n\t};\n\t\n\ttag.prototype.setValue = function (value){\n\t\tif (this._localValue == undefined) {\n\t\t\tthis.dom().value = this._value = value;\n\t\t};\n\t\treturn this;\n\t};\n\t\n\ttag.prototype.oninput = function (e){\n\t\tlet val = this._dom.value;\n\t\tthis._localValue = val;\n\t\tif (this._data && !(this.lazy())) { return this._data.setFormValue(this.value(),this) };\n\t};\n\t\n\ttag.prototype.onchange = function (e){\n\t\tthis._modelValue = this._localValue = undefined;\n\t\tif (!(this.data())) { return };\n\t\t\n\t\tif (this.type() == 'radio' || this.type() == 'checkbox') {\n\t\t\tlet checked = this._dom.checked;\n\t\t\tlet mval = this._data.getFormValue(this);\n\t\t\tlet dval = (this._value != undefined) ? this._value : this.value();\n\t\t\t\n\t\t\tif (this.type() == 'radio') {\n\t\t\t\treturn this._data.setFormValue(dval,this);\n\t\t\t} else if (this.dom().value == 'on') {\n\t\t\t\treturn this._data.setFormValue(!!checked,this);\n\t\t\t} else if (isArray(mval)) {\n\t\t\t\tlet idx = mval.indexOf(dval);\n\t\t\t\tif (checked && idx == -1) {\n\t\t\t\t\treturn mval.push(dval);\n\t\t\t\t} else if (!checked && idx >= 0) {\n\t\t\t\t\treturn mval.splice(idx,1);\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\treturn this._data.setFormValue(dval,this);\n\t\t\t};\n\t\t} else {\n\t\t\treturn this._data.setFormValue(this.value());\n\t\t};\n\t};\n\t\n\ttag.prototype.onblur = function (e){\n\t\treturn this._localValue = undefined;\n\t};\n\t\n\t// overriding end directly for performance\n\ttag.prototype.end = function (){\n\t\tif (this._localValue !== undefined || !this._data) {\n\t\t\treturn this;\n\t\t};\n\t\t\n\t\tlet mval = this._data.getFormValue(this);\n\t\tif (mval == this._modelValue) { return this };\n\t\tif (!isArray(mval)) { this._modelValue = mval };\n\t\t\n\t\tif (this.type() == 'radio' || this.type() == 'checkbox') {\n\t\t\tlet dval = this._value;\n\t\t\tlet checked = isArray(mval) ? (\n\t\t\t\tmval.indexOf(dval) >= 0\n\t\t\t) : ((this.dom().value == 'on') ? (\n\t\t\t\t!!mval\n\t\t\t) : (\n\t\t\t\tmval == this._value\n\t\t\t));\n\t\t\t\n\t\t\tthis._dom.checked = checked;\n\t\t} else {\n\t\t\tthis._dom.value = mval;\n\t\t};\n\t\treturn this;\n\t};\n});\n\nImba.extendTag('textarea', function(tag){\n\ttag.prototype.lazy = function(v){ return this._lazy; }\n\ttag.prototype.setLazy = function(v){ this._lazy = v; return this; };\n\t\n\ttag.prototype.bindData = function (target,path,args){\n\t\tDataProxy.bind(this,target,path,args);\n\t\treturn this;\n\t};\n\t\n\ttag.prototype.setValue = function (value){\n\t\tif (this._localValue == undefined) { this.dom().value = value };\n\t\treturn this;\n\t};\n\t\n\ttag.prototype.oninput = function (e){\n\t\tlet val = this._dom.value;\n\t\tthis._localValue = val;\n\t\tif (this._data && !(this.lazy())) { return this._data.setFormValue(this.value(),this) };\n\t};\n\t\n\ttag.prototype.onchange = function (e){\n\t\tthis._localValue = undefined;\n\t\tif (this._data) { return this._data.setFormValue(this.value(),this) };\n\t};\n\t\n\ttag.prototype.onblur = function (e){\n\t\treturn this._localValue = undefined;\n\t};\n\t\n\ttag.prototype.render = function (){\n\t\tif (this._localValue != undefined || !this._data) { return };\n\t\tif (this._data) {\n\t\t\tlet dval = this._data.getFormValue(this);\n\t\t\tthis._dom.value = (dval != undefined) ? dval : '';\n\t\t};\n\t\treturn this;\n\t};\n});\n\nImba.extendTag('option', function(tag){\n\ttag.prototype.setValue = function (value){\n\t\tif (value != this._value) {\n\t\t\tthis.dom().value = this._value = value;\n\t\t};\n\t\treturn this;\n\t};\n\t\n\ttag.prototype.value = function (){\n\t\treturn this._value || this.dom().value;\n\t};\n});\n\nImba.extendTag('select', function(tag){\n\ttag.prototype.bindData = function (target,path,args){\n\t\tDataProxy.bind(this,target,path,args);\n\t\treturn this;\n\t};\n\t\n\ttag.prototype.setValue = function (value,syncing){\n\t\tlet prev = this._value;\n\t\tthis._value = value;\n\t\tif (!syncing) { this.syncValue(value) };\n\t\treturn this;\n\t};\n\t\n\ttag.prototype.syncValue = function (value){\n\t\tlet prev = this._syncValue;\n\t\t// check if value has changed\n\t\tif (this.multiple() && (value instanceof Array)) {\n\t\t\tif ((prev instanceof Array) && isSimilarArray(prev,value)) {\n\t\t\t\treturn this;\n\t\t\t};\n\t\t\t// create a copy for syncValue\n\t\t\tvalue = value.slice();\n\t\t};\n\t\t\n\t\tthis._syncValue = value;\n\t\t// support array for multiple?\n\t\tif (typeof value == 'object') {\n\t\t\tlet mult = this.multiple() && (value instanceof Array);\n\t\t\t\n\t\t\tfor (let i = 0, items = iter$(this.dom().options), len = items.length, opt; i < len; i++) {\n\t\t\t\topt = items[i];\n\t\t\t\tlet oval = (opt._tag ? opt._tag.value() : opt.value);\n\t\t\t\tif (mult) {\n\t\t\t\t\topt.selected = value.indexOf(oval) >= 0;\n\t\t\t\t} else if (value == oval) {\n\t\t\t\t\tthis.dom().selectedIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t};\n\t\t\t};\n\t\t} else {\n\t\t\tthis.dom().value = value;\n\t\t};\n\t\treturn this;\n\t};\n\t\n\ttag.prototype.value = function (){\n\t\tif (this.multiple()) {\n\t\t\tlet res = [];\n\t\t\tfor (let i = 0, items = iter$(this.dom().selectedOptions), len = items.length, option; i < len; i++) {\n\t\t\t\toption = items[i];\n\t\t\t\tres.push(option._tag ? option._tag.value() : option.value);\n\t\t\t};\n\t\t\treturn res;\n\t\t} else {\n\t\t\tlet opt = this.dom().selectedOptions[0];\n\t\t\treturn opt ? ((opt._tag ? opt._tag.value() : opt.value)) : null;\n\t\t};\n\t};\n\t\n\ttag.prototype.onchange = function (e){\n\t\tif (this._data) { return this._data.setFormValue(this.value(),this) };\n\t};\n\t\n\ttag.prototype.end = function (){\n\t\tif (this._data) {\n\t\t\tthis.setValue(this._data.getFormValue(this),1);\n\t\t};\n\t\t\n\t\tif (this._value != this._syncValue) {\n\t\t\tthis.syncValue(this._value);\n\t\t};\n\t\treturn this;\n\t};\n});\n\n\n//# sourceURL=webpack:///./node_modules/imba/src/imba/dom/html.imba?");

/***/ }),

/***/ "./node_modules/imba/src/imba/dom/index.imba":
/*!***************************************************!*\
  !*** ./node_modules/imba/src/imba/dom/index.imba ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var Imba = __webpack_require__(/*! ../imba */ \"./node_modules/imba/src/imba/imba.imba\");\n\n__webpack_require__(/*! ./manager */ \"./node_modules/imba/src/imba/dom/manager.imba\");\n__webpack_require__(/*! ./event-manager */ \"./node_modules/imba/src/imba/dom/event-manager.imba\");\n\nImba.TagManager = new Imba.TagManagerClass();\n\n__webpack_require__(/*! ./tag */ \"./node_modules/imba/src/imba/dom/tag.imba\");\n__webpack_require__(/*! ./html */ \"./node_modules/imba/src/imba/dom/html.imba\");\n__webpack_require__(/*! ./pointer */ \"./node_modules/imba/src/imba/dom/pointer.imba\");\n__webpack_require__(/*! ./touch */ \"./node_modules/imba/src/imba/dom/touch.imba\");\n__webpack_require__(/*! ./event */ \"./node_modules/imba/src/imba/dom/event.imba\");\n\nif (true) {\n\t__webpack_require__(/*! ./reconciler */ \"./node_modules/imba/src/imba/dom/reconciler.imba\");\n};\n\nif (false) {};\n\n\n//# sourceURL=webpack:///./node_modules/imba/src/imba/dom/index.imba?");

/***/ }),

/***/ "./node_modules/imba/src/imba/dom/manager.imba":
/*!*****************************************************!*\
  !*** ./node_modules/imba/src/imba/dom/manager.imba ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };\nvar Imba = __webpack_require__(/*! ../imba */ \"./node_modules/imba/src/imba/imba.imba\");\n\nImba.TagManagerClass = function TagManagerClass(){\n\tthis._inserts = 0;\n\tthis._removes = 0;\n\tthis._mounted = [];\n\tthis._mountables = 0;\n\tthis._unmountables = 0;\n\tthis;\n};\n\nImba.TagManagerClass.prototype.mounted = function (){\n\treturn this._mounted;\n};\n\nImba.TagManagerClass.prototype.insert = function (node,parent){\n\tthis._inserts++;\n\tif (node && node.mount) {\n\t\tif (!(node.FLAGS & Imba.TAG_MOUNTABLE)) {\n\t\t\tnode.FLAGS |= Imba.TAG_MOUNTABLE;\n\t\t\tthis._mountables++;\n\t\t};\n\t};\n\treturn;\n};\n\nImba.TagManagerClass.prototype.remove = function (node,parent){\n\treturn this._removes++;\n};\n\n\nImba.TagManagerClass.prototype.changes = function (){\n\treturn this._inserts + this._removes;\n};\n\nImba.TagManagerClass.prototype.mount = function (node){\n\treturn;\n};\n\nImba.TagManagerClass.prototype.refresh = function (force){\n\tif(force === undefined) force = false;\n\tif (false) {};\n\tif (!force && this.changes() == 0) { return };\n\t// console.time('resolveMounts')\n\tif ((this._inserts && this._mountables > this._mounted.length) || force) {\n\t\tthis.tryMount();\n\t};\n\t\n\tif ((this._removes || force) && this._mounted.length) {\n\t\tthis.tryUnmount();\n\t};\n\t// console.timeEnd('resolveMounts')\n\tthis._inserts = 0;\n\tthis._removes = 0;\n\treturn this;\n};\n\nImba.TagManagerClass.prototype.unmount = function (node){\n\treturn this;\n};\n\nImba.TagManagerClass.prototype.tryMount = function (){\n\tvar count = 0;\n\tvar root = document.body;\n\tvar items = root.querySelectorAll('.__mount');\n\t// what if we end up creating additional mountables by mounting?\n\tfor (let i = 0, ary = iter$(items), len = ary.length, el; i < len; i++) {\n\t\tel = ary[i];\n\t\tif (el && el._tag) {\n\t\t\tif (this._mounted.indexOf(el._tag) == -1) {\n\t\t\t\tthis.mountNode(el._tag);\n\t\t\t};\n\t\t};\n\t};\n\treturn this;\n};\n\nImba.TagManagerClass.prototype.mountNode = function (node){\n\tif (this._mounted.indexOf(node) == -1) {\n\t\tthis._mounted.push(node);\n\t\tnode.FLAGS |= Imba.TAG_MOUNTED;\n\t\tif (node.mount) { node.mount() };\n\t\t// Mark all parents as mountable for faster unmount\n\t\tlet el = node.dom().parentNode;\n\t\twhile (el && el._tag && !el._tag.mount && !(el._tag.FLAGS & Imba.TAG_MOUNTABLE)){\n\t\t\tel._tag.FLAGS |= Imba.TAG_MOUNTABLE;\n\t\t\tel = el.parentNode;\n\t\t};\n\t};\n\t\n\treturn;\n};\n\nImba.TagManagerClass.prototype.tryUnmount = function (){\n\tvar count = 0;\n\tvar root = document.body;\n\tfor (let i = 0, items = iter$(this._mounted), len = items.length, item; i < len; i++) {\n\t\titem = items[i];\n\t\tif (!document.documentElement.contains(item._dom)) {\n\t\t\titem.FLAGS = item.FLAGS & ~Imba.TAG_MOUNTED;\n\t\t\tif (item.unmount && item._dom) {\n\t\t\t\titem.unmount();\n\t\t\t} else if (item._scheduler) {\n\t\t\t\t// MAYBE FIX THIS?\n\t\t\t\titem.unschedule();\n\t\t\t};\n\t\t\tthis._mounted[i] = null;\n\t\t\tcount++;\n\t\t};\n\t};\n\t\n\tif (count) {\n\t\tthis._mounted = this._mounted.filter(function(item) { return item; });\n\t};\n\treturn this;\n};\n\n\n//# sourceURL=webpack:///./node_modules/imba/src/imba/dom/manager.imba?");

/***/ }),

/***/ "./node_modules/imba/src/imba/dom/pointer.imba":
/*!*****************************************************!*\
  !*** ./node_modules/imba/src/imba/dom/pointer.imba ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var Imba = __webpack_require__(/*! ../imba */ \"./node_modules/imba/src/imba/imba.imba\");\n\nImba.Pointer = function Pointer(){\n\tthis._button = -1;\n\tthis._event = {x: 0,y: 0,type: 'uninitialized'};\n\treturn this;\n};\n\nImba.Pointer.prototype.button = function (){\n\treturn this._button;\n};\n\nImba.Pointer.prototype.touch = function (){\n\treturn this._touch;\n};\n\nImba.Pointer.prototype.update = function (e){\n\tthis._event = e;\n\tthis._dirty = true;\n\treturn this;\n};\n\n// this is just for regular mouse now\nImba.Pointer.prototype.process = function (){\n\tvar e1 = this._event;\n\t\n\tif (this._dirty) {\n\t\tthis._prevEvent = e1;\n\t\tthis._dirty = false;\n\t\t\n\t\t// button should only change on mousedown etc\n\t\tif (e1.type == 'mousedown') {\n\t\t\tthis._button = e1.button;\n\t\t\t\n\t\t\tif ((this._touch && this._button != 0)) {\n\t\t\t\treturn;\n\t\t\t};\n\t\t\t\n\t\t\t// cancel the previous touch\n\t\t\tif (this._touch) { this._touch.cancel() };\n\t\t\tthis._touch = new Imba.Touch(e1,this);\n\t\t\tthis._touch.mousedown(e1,e1);\n\t\t} else if (e1.type == 'mousemove') {\n\t\t\tif (this._touch) { this._touch.mousemove(e1,e1) };\n\t\t} else if (e1.type == 'mouseup') {\n\t\t\tthis._button = -1;\n\t\t\t\n\t\t\tif (this._touch && this._touch.button() == e1.button) {\n\t\t\t\tthis._touch.mouseup(e1,e1);\n\t\t\t\tthis._touch = null;\n\t\t\t};\n\t\t\t// trigger pointerup\n\t\t};\n\t} else if (this._touch) {\n\t\tthis._touch.idle();\n\t};\n\treturn this;\n};\n\nImba.Pointer.prototype.x = function (){\n\treturn this._event.x;\n};\nImba.Pointer.prototype.y = function (){\n\treturn this._event.y;\n};\n\n\n//# sourceURL=webpack:///./node_modules/imba/src/imba/dom/pointer.imba?");

/***/ }),

/***/ "./node_modules/imba/src/imba/dom/reconciler.imba":
/*!********************************************************!*\
  !*** ./node_modules/imba/src/imba/dom/reconciler.imba ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };\n// externs;\n\nvar Imba = __webpack_require__(/*! ../imba */ \"./node_modules/imba/src/imba/imba.imba\");\n\nfunction removeNested(root,node,caret){\n\t// if node/nodes isa String\n\t// \twe need to use the caret to remove elements\n\t// \tfor now we will simply not support this\n\tif (node instanceof Array) {\n\t\tfor (let i = 0, items = iter$(node), len = items.length; i < len; i++) {\n\t\t\tremoveNested(root,items[i],caret);\n\t\t};\n\t} else if (node && node._slot_) {\n\t\troot.removeChild(node);\n\t} else if (node != null) {\n\t\t// what if this is not null?!?!?\n\t\t// take a chance and remove a text-elementng\n\t\tlet next = caret ? caret.nextSibling : root._dom.firstChild;\n\t\tif ((next instanceof Text) && next.textContent == node) {\n\t\t\troot.removeChild(next);\n\t\t} else {\n\t\t\tthrow 'cannot remove string';\n\t\t};\n\t};\n\t\n\treturn caret;\n};\n\nfunction appendNested(root,node){\n\tif (node instanceof Array) {\n\t\tlet i = 0;\n\t\tlet c = node.taglen;\n\t\tlet k = (c != null) ? ((node.domlen = c)) : node.length;\n\t\twhile (i < k){\n\t\t\tappendNested(root,node[i++]);\n\t\t};\n\t} else if (node && node._dom) {\n\t\troot.appendChild(node);\n\t} else if (node != null && node !== false) {\n\t\troot.appendChild(Imba.createTextNode(node));\n\t};\n\t\n\treturn;\n};\n\n\n// insert nodes before a certain node\n// does not need to return any tail, as before\n// will still be correct there\n// before must be an actual domnode\nfunction insertNestedBefore(root,node,before){\n\tif (node instanceof Array) {\n\t\tlet i = 0;\n\t\tlet c = node.taglen;\n\t\tlet k = (c != null) ? ((node.domlen = c)) : node.length;\n\t\twhile (i < k){\n\t\t\tinsertNestedBefore(root,node[i++],before);\n\t\t};\n\t} else if (node && node._dom) {\n\t\troot.insertBefore(node,before);\n\t} else if (node != null && node !== false) {\n\t\troot.insertBefore(Imba.createTextNode(node),before);\n\t};\n\t\n\treturn before;\n};\n\n// after must be an actual domnode\nfunction insertNestedAfter(root,node,after){\n\tvar before = after ? after.nextSibling : root._dom.firstChild;\n\t\n\tif (before) {\n\t\tinsertNestedBefore(root,node,before);\n\t\treturn before.previousSibling;\n\t} else {\n\t\tappendNested(root,node);\n\t\treturn root._dom.lastChild;\n\t};\n};\n\nfunction reconcileCollectionChanges(root,new$,old,caret){\n\t\n\tvar newLen = new$.length;\n\tvar lastNew = new$[newLen - 1];\n\t\n\t// This re-order algorithm is based on the following principle:\n\t// \n\t// We build a \"chain\" which shows which items are already sorted.\n\t// If we're going from [1, 2, 3] -> [2, 1, 3], the tree looks like:\n\t//\n\t// \t3 ->  0 (idx)\n\t// \t2 -> -1 (idx)\n\t// \t1 -> -1 (idx)\n\t//\n\t// This tells us that we have two chains of ordered items:\n\t// \n\t// \t(1, 3) and (2)\n\t// \n\t// The optimal re-ordering then becomes to keep the longest chain intact,\n\t// and move all the other items.\n\t\n\tvar newPosition = [];\n\t\n\t// The tree/graph itself\n\tvar prevChain = [];\n\t// The length of the chain\n\tvar lengthChain = [];\n\t\n\t// Keep track of the longest chain\n\tvar maxChainLength = 0;\n\tvar maxChainEnd = 0;\n\t\n\tvar hasTextNodes = false;\n\tvar newPos;\n\t\n\tfor (let idx = 0, items = iter$(old), len = items.length, node; idx < len; idx++) {\n\t\t// special case for Text nodes\n\t\tnode = items[idx];\n\t\tif (node && node.nodeType == 3) {\n\t\t\tnewPos = new$.indexOf(node.textContent);\n\t\t\tif (newPos >= 0) { new$[newPos] = node };\n\t\t\thasTextNodes = true;\n\t\t} else {\n\t\t\tnewPos = new$.indexOf(node);\n\t\t};\n\t\t\n\t\tnewPosition.push(newPos);\n\t\t\n\t\tif (newPos == -1) {\n\t\t\troot.removeChild(node);\n\t\t\tprevChain.push(-1);\n\t\t\tlengthChain.push(-1);\n\t\t\tcontinue;\n\t\t};\n\t\t\n\t\tvar prevIdx = newPosition.length - 2;\n\t\t\n\t\t// Build the chain:\n\t\twhile (prevIdx >= 0){\n\t\t\tif (newPosition[prevIdx] == -1) {\n\t\t\t\tprevIdx--;\n\t\t\t} else if (newPos > newPosition[prevIdx]) {\n\t\t\t\t// Yay, we're bigger than the previous!\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\t// Nope, let's walk back the chain\n\t\t\t\tprevIdx = prevChain[prevIdx];\n\t\t\t};\n\t\t};\n\t\t\n\t\tprevChain.push(prevIdx);\n\t\t\n\t\tvar currLength = (prevIdx == -1) ? 0 : (lengthChain[prevIdx] + 1);\n\t\t\n\t\tif (currLength > maxChainLength) {\n\t\t\tmaxChainLength = currLength;\n\t\t\tmaxChainEnd = idx;\n\t\t};\n\t\t\n\t\tlengthChain.push(currLength);\n\t};\n\t\n\tvar stickyNodes = [];\n\t\n\t// Now we can walk the longest chain backwards and mark them as \"sticky\",\n\t// which implies that they should not be moved\n\tvar cursor = newPosition.length - 1;\n\twhile (cursor >= 0){\n\t\tif (cursor == maxChainEnd && newPosition[cursor] != -1) {\n\t\t\tstickyNodes[newPosition[cursor]] = true;\n\t\t\tmaxChainEnd = prevChain[maxChainEnd];\n\t\t};\n\t\t\n\t\tcursor -= 1;\n\t};\n\t\n\t// possible to do this in reversed order instead?\n\tfor (let idx = 0, items = iter$(new$), len = items.length, node; idx < len; idx++) {\n\t\tnode = items[idx];\n\t\tif (!stickyNodes[idx]) {\n\t\t\t// create textnode for string, and update the array\n\t\t\tif (!(node && node._dom)) {\n\t\t\t\tnode = new$[idx] = Imba.createTextNode(node);\n\t\t\t};\n\t\t\t\n\t\t\tvar after = new$[idx - 1];\n\t\t\tinsertNestedAfter(root,node,(after && after._slot_ || after || caret));\n\t\t};\n\t\t\n\t\tcaret = node._slot_ || (caret && caret.nextSibling || root._dom.firstChild);\n\t};\n\t\n\t// should trust that the last item in new list is the caret\n\treturn lastNew && lastNew._slot_ || caret;\n};\n\n\n// expects a flat non-sparse array of nodes in both new and old, always\nfunction reconcileCollection(root,new$,old,caret){\n\tvar k = new$.length;\n\tvar i = k;\n\tvar last = new$[k - 1];\n\t\n\t\n\tif (k == old.length && new$[0] === old[0]) {\n\t\t// running through to compare\n\t\twhile (i--){\n\t\t\tif (new$[i] !== old[i]) { break; };\n\t\t};\n\t};\n\t\n\tif (i == -1) {\n\t\treturn last && last._slot_ || last || caret;\n\t} else {\n\t\treturn reconcileCollectionChanges(root,new$,old,caret);\n\t};\n};\n\n// TYPE 5 - we know that we are dealing with a single array of\n// keyed tags - and root has no other children\nfunction reconcileLoop(root,new$,old,caret){\n\tvar nl = new$.length;\n\tvar ol = old.length;\n\tvar cl = new$.cache.i$; // cache-length\n\tvar i = 0,d = nl - ol;\n\t\n\t// TODO support caret\n\t\n\t// find the first index that is different\n\twhile (i < ol && i < nl && new$[i] === old[i]){\n\t\ti++;\n\t};\n\t\n\t// conditionally prune cache\n\tif (cl > 1000 && (cl - nl) > 500) {\n\t\tnew$.cache.$prune(new$);\n\t};\n\t\n\tif (d > 0 && i == ol) {\n\t\t// added at end\n\t\twhile (i < nl){\n\t\t\troot.appendChild(new$[i++]);\n\t\t};\n\t\treturn;\n\t} else if (d > 0) {\n\t\tlet i1 = nl;\n\t\twhile (i1 > i && new$[i1 - 1] === old[i1 - 1 - d]){\n\t\t\ti1--;\n\t\t};\n\t\t\n\t\tif (d == (i1 - i)) {\n\t\t\tlet before = old[i]._slot_;\n\t\t\twhile (i < i1){\n\t\t\t\troot.insertBefore(new$[i++],before);\n\t\t\t};\n\t\t\treturn;\n\t\t};\n\t} else if (d < 0 && i == nl) {\n\t\t// removed at end\n\t\twhile (i < ol){\n\t\t\troot.removeChild(old[i++]);\n\t\t};\n\t\treturn;\n\t} else if (d < 0) {\n\t\tlet i1 = ol;\n\t\twhile (i1 > i && new$[i1 - 1 + d] === old[i1 - 1]){\n\t\t\ti1--;\n\t\t};\n\t\t\n\t\tif (d == (i - i1)) {\n\t\t\twhile (i < i1){\n\t\t\t\troot.removeChild(old[i++]);\n\t\t\t};\n\t\t\treturn;\n\t\t};\n\t} else if (i == nl) {\n\t\treturn;\n\t};\n\t\n\treturn reconcileCollectionChanges(root,new$,old,caret);\n};\n\n// expects a flat non-sparse array of nodes in both new and old, always\nfunction reconcileIndexedArray(root,array,old,caret){\n\tvar newLen = array.taglen;\n\tvar prevLen = array.domlen || 0;\n\tvar last = newLen ? array[newLen - 1] : null;\n\t// console.log \"reconcile optimized array(!)\",caret,newLen,prevLen,array\n\t\n\tif (prevLen > newLen) {\n\t\twhile (prevLen > newLen){\n\t\t\tvar item = array[--prevLen];\n\t\t\troot.removeChild(item._slot_);\n\t\t};\n\t} else if (newLen > prevLen) {\n\t\t// find the item to insert before\n\t\tlet prevLast = prevLen ? array[prevLen - 1]._slot_ : caret;\n\t\tlet before = prevLast ? prevLast.nextSibling : root._dom.firstChild;\n\t\t\n\t\twhile (prevLen < newLen){\n\t\t\tlet node = array[prevLen++];\n\t\t\tbefore ? root.insertBefore(node._slot_,before) : root.appendChild(node._slot_);\n\t\t};\n\t};\n\t\n\tarray.domlen = newLen;\n\treturn last ? last._slot_ : caret;\n};\n\n\n// the general reconciler that respects conditions etc\n// caret is the current node we want to insert things after\nfunction reconcileNested(root,new$,old,caret){\n\t\n\t// var skipnew = new == null or new === false or new === true\n\tvar newIsNull = new$ == null || new$ === false;\n\tvar oldIsNull = old == null || old === false;\n\t\n\t\n\tif (new$ === old) {\n\t\t// remember that the caret must be an actual dom element\n\t\t// we should instead move the actual caret? - trust\n\t\tif (newIsNull) {\n\t\t\treturn caret;\n\t\t} else if (new$._slot_) {\n\t\t\treturn new$._slot_;\n\t\t} else if ((new$ instanceof Array) && new$.taglen != null) {\n\t\t\treturn reconcileIndexedArray(root,new$,old,caret);\n\t\t} else {\n\t\t\treturn caret ? caret.nextSibling : root._dom.firstChild;\n\t\t};\n\t} else if (new$ instanceof Array) {\n\t\tif (old instanceof Array) {\n\t\t\t// look for slot instead?\n\t\t\tlet typ = new$.static;\n\t\t\tif (typ || old.static) {\n\t\t\t\t// if the static is not nested - we could get a hint from compiler\n\t\t\t\t// and just skip it\n\t\t\t\tif (typ == old.static) { // should also include a reference?\n\t\t\t\t\tfor (let i = 0, items = iter$(new$), len = items.length; i < len; i++) {\n\t\t\t\t\t\t// this is where we could do the triple equal directly\n\t\t\t\t\t\tcaret = reconcileNested(root,items[i],old[i],caret);\n\t\t\t\t\t};\n\t\t\t\t\treturn caret;\n\t\t\t\t} else {\n\t\t\t\t\tremoveNested(root,old,caret);\n\t\t\t\t};\n\t\t\t\t\n\t\t\t\t// if they are not the same we continue through to the default\n\t\t\t} else {\n\t\t\t\t// Could use optimized loop if we know that it only consists of nodes\n\t\t\t\treturn reconcileCollection(root,new$,old,caret);\n\t\t\t};\n\t\t} else if (!oldIsNull) {\n\t\t\tif (old._slot_) {\n\t\t\t\troot.removeChild(old);\n\t\t\t} else {\n\t\t\t\t// old was a string-like object?\n\t\t\t\troot.removeChild(caret ? caret.nextSibling : root._dom.firstChild);\n\t\t\t};\n\t\t};\n\t\t\n\t\treturn insertNestedAfter(root,new$,caret);\n\t\t// remove old\n\t} else if (!newIsNull && new$._slot_) {\n\t\tif (!oldIsNull) { removeNested(root,old,caret) };\n\t\treturn insertNestedAfter(root,new$,caret);\n\t} else if (newIsNull) {\n\t\tif (!oldIsNull) { removeNested(root,old,caret) };\n\t\treturn caret;\n\t} else {\n\t\t// if old did not exist we need to add a new directly\n\t\tlet nextNode;\n\t\t// if old was array or imbatag we need to remove it and then add\n\t\tif (old instanceof Array) {\n\t\t\tremoveNested(root,old,caret);\n\t\t} else if (old && old._slot_) {\n\t\t\troot.removeChild(old);\n\t\t} else if (!oldIsNull) {\n\t\t\t// ...\n\t\t\tnextNode = caret ? caret.nextSibling : root._dom.firstChild;\n\t\t\tif ((nextNode instanceof Text) && nextNode.textContent != new$) {\n\t\t\t\tnextNode.textContent = new$;\n\t\t\t\treturn nextNode;\n\t\t\t};\n\t\t};\n\t\t\n\t\t// now add the textnode\n\t\treturn insertNestedAfter(root,new$,caret);\n\t};\n};\n\n\nImba.extendTag('element', function(tag){\n\t\n\t// 1 - static shape - unknown content\n\t// 2 - static shape and static children\n\t// 3 - single item\n\t// 4 - optimized array - only length will change\n\t// 5 - optimized collection\n\t// 6 - text only\n\t\n\ttag.prototype.setChildren = function (new$,typ){\n\t\t// if typeof new == 'string'\n\t\t// \treturn self.text = new\n\t\tvar old = this._tree_;\n\t\t\n\t\tif (new$ === old && (!(new$) || new$.taglen == undefined)) {\n\t\t\treturn this;\n\t\t};\n\t\t\n\t\tif (!old && typ != 3) {\n\t\t\tthis.removeAllChildren();\n\t\t\tappendNested(this,new$);\n\t\t} else if (typ == 1) {\n\t\t\tlet caret = null;\n\t\t\tfor (let i = 0, items = iter$(new$), len = items.length; i < len; i++) {\n\t\t\t\tcaret = reconcileNested(this,items[i],old[i],caret);\n\t\t\t};\n\t\t} else if (typ == 2) {\n\t\t\treturn this;\n\t\t} else if (typ == 3) {\n\t\t\tlet ntyp = typeof new$;\n\t\t\t\n\t\t\tif (ntyp != 'object') {\n\t\t\t\treturn this.setText(new$);\n\t\t\t};\n\t\t\t\n\t\t\tif (new$ && new$._dom) {\n\t\t\t\tthis.removeAllChildren();\n\t\t\t\tthis.appendChild(new$);\n\t\t\t} else if (new$ instanceof Array) {\n\t\t\t\tif (new$._type == 5 && old && old._type == 5) {\n\t\t\t\t\treconcileLoop(this,new$,old,null);\n\t\t\t\t} else if (old instanceof Array) {\n\t\t\t\t\treconcileNested(this,new$,old,null);\n\t\t\t\t} else {\n\t\t\t\t\tthis.removeAllChildren();\n\t\t\t\t\tappendNested(this,new$);\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\treturn this.setText(new$);\n\t\t\t};\n\t\t} else if (typ == 4) {\n\t\t\treconcileIndexedArray(this,new$,old,null);\n\t\t} else if (typ == 5) {\n\t\t\treconcileLoop(this,new$,old,null);\n\t\t} else if ((new$ instanceof Array) && (old instanceof Array)) {\n\t\t\treconcileNested(this,new$,old,null);\n\t\t} else {\n\t\t\t// what if text?\n\t\t\tthis.removeAllChildren();\n\t\t\tappendNested(this,new$);\n\t\t};\n\t\t\n\t\tthis._tree_ = new$;\n\t\treturn this;\n\t};\n\t\n\ttag.prototype.content = function (){\n\t\treturn this._content || this.children().toArray();\n\t};\n\t\n\ttag.prototype.setText = function (text){\n\t\tif (text != this._tree_) {\n\t\t\tvar val = (text === null || text === false) ? '' : text;\n\t\t\t(this._text_ || this._dom).textContent = val;\n\t\t\tthis._text_ || (this._text_ = this._dom.firstChild);\n\t\t\tthis._tree_ = text;\n\t\t};\n\t\treturn this;\n\t};\n});\n\n// alias setContent to setChildren\nvar proto = Imba.Tag.prototype;\nproto.setContent = proto.setChildren;\n\n// optimization for setText\nvar apple = typeof navigator != 'undefined' && (navigator.vendor || '').indexOf('Apple') == 0;\nif (apple) {\n\tproto.setText = function (text){\n\t\tif (text != this._tree_) {\n\t\t\tthis._dom.textContent = ((text === null || text === false) ? '' : text);\n\t\t\tthis._tree_ = text;\n\t\t};\n\t\treturn this;\n\t};\n};\n\n\n//# sourceURL=webpack:///./node_modules/imba/src/imba/dom/reconciler.imba?");

/***/ }),

/***/ "./node_modules/imba/src/imba/dom/tag.imba":
/*!*************************************************!*\
  !*** ./node_modules/imba/src/imba/dom/tag.imba ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };\nvar Imba = __webpack_require__(/*! ../imba */ \"./node_modules/imba/src/imba/imba.imba\");\n\nImba.CSSKeyMap = {};\n\nImba.TAG_BUILT = 1;\nImba.TAG_SETUP = 2;\nImba.TAG_MOUNTING = 4;\nImba.TAG_MOUNTED = 8;\nImba.TAG_SCHEDULED = 16;\nImba.TAG_AWAKENED = 32;\nImba.TAG_MOUNTABLE = 64;\n\n/*\nGet the current document\n*/\n\nImba.document = function (){\n\tif (true) {\n\t\treturn window.document;\n\t};\n};\n\n/*\nGet the body element wrapped in an Imba.Tag\n*/\n\nImba.root = function (){\n\treturn Imba.getTagForDom(Imba.document().body);\n};\n\nImba.static = function (items,typ,nr){\n\titems._type = typ;\n\titems.static = nr;\n\treturn items;\n};\n\n/*\n\n*/\n\nImba.mount = function (node,into){\n\tinto || (into = Imba.document().body);\n\tinto.appendChild(node.dom());\n\tImba.TagManager.insert(node,into);\n\tnode.scheduler().configure({events: true}).activate(false);\n\tImba.TagManager.refresh();\n\treturn node;\n};\n\n\nImba.createTextNode = function (node){\n\tif (node && node.nodeType == 3) {\n\t\treturn node;\n\t};\n\treturn Imba.document().createTextNode(node);\n};\n\n\n\n/*\nThis is the baseclass that all tags in imba inherit from.\n@iname node\n*/\n\nImba.Tag = function Tag(dom,ctx){\n\tthis.setDom(dom);\n\tthis.$ = TagCache.build(this);\n\tthis.$up = this._owner_ = ctx;\n\tthis._tree_ = null;\n\tthis.FLAGS = 0;\n\tthis.build();\n\tthis;\n};\n\nImba.Tag.buildNode = function (){\n\tvar dom = Imba.document().createElement(this._nodeType || 'div');\n\tif (this._classes) {\n\t\tvar cls = this._classes.join(\" \");\n\t\tif (cls) { dom.className = cls };\n\t};\n\treturn dom;\n};\n\nImba.Tag.createNode = function (){\n\tvar proto = (this._protoDom || (this._protoDom = this.buildNode()));\n\treturn proto.cloneNode(false);\n};\n\nImba.Tag.build = function (ctx){\n\treturn new this(this.createNode(),ctx);\n};\n\nImba.Tag.dom = function (){\n\treturn this._protoDom || (this._protoDom = this.buildNode());\n};\n\nImba.Tag.end = function (){\n\treturn this.commit(0);\n};\n\n/*\n\tCalled when a tag type is being subclassed.\n\t*/\n\nImba.Tag.inherit = function (child){\n\tchild._protoDom = null;\n\t\n\tif (this._nodeType) {\n\t\tchild._nodeType = this._nodeType;\n\t\tchild._classes = this._classes.slice();\n\t\t\n\t\tif (child._flagName) {\n\t\t\treturn child._classes.push(child._flagName);\n\t\t};\n\t} else {\n\t\tchild._nodeType = child._name;\n\t\tchild._flagName = null;\n\t\treturn child._classes = [];\n\t};\n};\n\n/*\n\tInternal method called after a tag class has\n\tbeen declared or extended.\n\t\n\t@private\n\t*/\n\nImba.Tag.prototype.optimizeTagStructure = function (){\n\tif (false) {};\n\tvar ctor = this.constructor;\n\tlet keys = Object.keys(this);\n\t\n\tif (keys.indexOf('mount') >= 0) {\n\t\tif (ctor._classes && ctor._classes.indexOf('__mount') == -1) {\n\t\t\tctor._classes.push('__mount');\n\t\t};\n\t\t\n\t\tif (ctor._protoDom) {\n\t\t\tctor._protoDom.classList.add('__mount');\n\t\t};\n\t};\n\t\n\tfor (let i = 0, items = iter$(keys), len = items.length, key; i < len; i++) {\n\t\tkey = items[i];\n\t\tif ((/^on/).test(key)) { Imba.EventManager.bind(key.slice(2)) };\n\t};\n\treturn this;\n};\n\n\nImba.attr(Imba.Tag,'name');\nImba.attr(Imba.Tag,'role');\nImba.attr(Imba.Tag,'tabindex');\nImba.Tag.prototype.title = function(v){ return this.getAttribute('title'); }\nImba.Tag.prototype.setTitle = function(v){ this.setAttribute('title',v); return this; };\n\nImba.Tag.prototype.dom = function (){\n\treturn this._dom;\n};\n\nImba.Tag.prototype.setDom = function (dom){\n\tdom._tag = this;\n\tthis._dom = this._slot_ = dom;\n\treturn this;\n};\n\nImba.Tag.prototype.ref = function (){\n\treturn this._ref;\n};\n\nImba.Tag.prototype.root = function (){\n\treturn this._owner_ ? this._owner_.root() : this;\n};\n\n/*\n\tSetting references for tags like\n\t`<div@header>` will compile to `tag('div').ref_('header',this).end()`\n\tBy default it adds the reference as a className to the tag.\n\n\t@return {self}\n\t@private\n\t*/\n\nImba.Tag.prototype.ref_ = function (ref){\n\tthis.flag(this._ref = ref);\n\treturn this;\n};\n\n/*\n\tSet the data object for node\n\t@return {self}\n\t*/\n\nImba.Tag.prototype.setData = function (data){\n\tthis._data = data;\n\treturn this;\n};\n\n/*\n\tGet the data object for node\n\t*/\n\nImba.Tag.prototype.data = function (){\n\treturn this._data;\n};\n\n\nImba.Tag.prototype.bindData = function (target,path,args){\n\treturn this.setData(args ? target[path].apply(target,args) : target[path]);\n};\n\n/*\n\tSet inner html of node\n\t*/\n\nImba.Tag.prototype.setHtml = function (html){\n\tif (this.html() != html) {\n\t\tthis._dom.innerHTML = html;\n\t};\n\treturn this;\n};\n\n/*\n\tGet inner html of node\n\t*/\n\nImba.Tag.prototype.html = function (){\n\treturn this._dom.innerHTML;\n};\n\nImba.Tag.prototype.on$ = function (slot,handler,context){\n\tlet handlers = this._on_ || (this._on_ = []);\n\tlet prev = handlers[slot];\n\t// self-bound handlers\n\tif (slot < 0) {\n\t\tif (prev == undefined) {\n\t\t\tslot = handlers[slot] = handlers.length;\n\t\t} else {\n\t\t\tslot = prev;\n\t\t};\n\t\tprev = handlers[slot];\n\t};\n\t\n\thandlers[slot] = handler;\n\tif (prev) {\n\t\thandler.state = prev.state;\n\t} else {\n\t\thandler.state = {context: context};\n\t\tif (true) { Imba.EventManager.bind(handler[0]) };\n\t};\n\treturn this;\n};\n\n\nImba.Tag.prototype.setId = function (id){\n\tif (id != null) {\n\t\tthis.dom().id = id;\n\t};\n\treturn this;\n};\n\nImba.Tag.prototype.id = function (){\n\treturn this.dom().id;\n};\n\n/*\n\tAdds a new attribute or changes the value of an existing attribute\n\ton the specified tag. If the value is null or false, the attribute\n\twill be removed.\n\t@return {self}\n\t*/\n\nImba.Tag.prototype.setAttribute = function (name,value){\n\tvar old = this.dom().getAttribute(name);\n\t\n\tif (old == value) {\n\t\tvalue;\n\t} else if (value != null && value !== false) {\n\t\tthis.dom().setAttribute(name,value);\n\t} else {\n\t\tthis.dom().removeAttribute(name);\n\t};\n\treturn this;\n};\n\nImba.Tag.prototype.setNestedAttr = function (ns,name,value){\n\tif (this[ns + 'SetAttribute']) {\n\t\tthis[ns + 'SetAttribute'](name,value);\n\t} else {\n\t\tthis.setAttributeNS(ns,name,value);\n\t};\n\treturn this;\n};\n\nImba.Tag.prototype.setAttributeNS = function (ns,name,value){\n\tvar old = this.getAttributeNS(ns,name);\n\t\n\tif (old != value) {\n\t\tif (value != null && value !== false) {\n\t\t\tthis.dom().setAttributeNS(ns,name,value);\n\t\t} else {\n\t\t\tthis.dom().removeAttributeNS(ns,name);\n\t\t};\n\t};\n\treturn this;\n};\n\n\n/*\n\tremoves an attribute from the specified tag\n\t*/\n\nImba.Tag.prototype.removeAttribute = function (name){\n\treturn this.dom().removeAttribute(name);\n};\n\n/*\n\treturns the value of an attribute on the tag.\n\tIf the given attribute does not exist, the value returned\n\twill either be null or \"\" (the empty string)\n\t*/\n\nImba.Tag.prototype.getAttribute = function (name){\n\treturn this.dom().getAttribute(name);\n};\n\n\nImba.Tag.prototype.getAttributeNS = function (ns,name){\n\treturn this.dom().getAttributeNS(ns,name);\n};\n\n\nImba.Tag.prototype.set = function (key,value,mods){\n\tlet setter = Imba.toSetter(key);\n\tif (this[setter] instanceof Function) {\n\t\tthis[setter](value,mods);\n\t} else {\n\t\tthis._dom.setAttribute(key,value);\n\t};\n\treturn this;\n};\n\n\nImba.Tag.prototype.get = function (key){\n\treturn this._dom.getAttribute(key);\n};\n\n/*\n\tOverride this to provide special wrapping etc.\n\t@return {self}\n\t*/\n\nImba.Tag.prototype.setContent = function (content,type){\n\tthis.setChildren(content,type);\n\treturn this;\n};\n\n/*\n\tSet the children of node. type param is optional,\n\tand should only be used by Imba when compiling tag trees. \n\t@return {self}\n\t*/\n\nImba.Tag.prototype.setChildren = function (nodes,type){\n\t// overridden on client by reconciler\n\tthis._tree_ = nodes;\n\treturn this;\n};\n\n/*\n\tSet the template that will render the content of node.\n\t@return {self}\n\t*/\n\nImba.Tag.prototype.setTemplate = function (template){\n\tif (!this._template) {\n\t\tif (this.render == Imba.Tag.prototype.render) {\n\t\t\tthis.render = this.renderTemplate; // do setChildren(renderTemplate)\n\t\t};\n\t};\n\t\n\tthis.template = this._template = template;\n\treturn this;\n};\n\nImba.Tag.prototype.template = function (){\n\treturn null;\n};\n\n/*\n\tIf no custom render-method is defined, and the node\n\thas a template, this method will be used to render\n\t@return {self}\n\t*/\n\nImba.Tag.prototype.renderTemplate = function (){\n\tvar body = this.template();\n\tif (body != this) { this.setChildren(body) };\n\treturn this;\n};\n\n\n/*\n\tRemove specified child from current node.\n\t@return {self}\n\t*/\n\nImba.Tag.prototype.removeChild = function (child){\n\tvar par = this.dom();\n\tvar el = child._slot_ || child;\n\tif (el && el.parentNode == par) {\n\t\tImba.TagManager.remove(el._tag || el,this);\n\t\tpar.removeChild(el);\n\t};\n\treturn this;\n};\n\n/*\n\tRemove all content inside node\n\t*/\n\nImba.Tag.prototype.removeAllChildren = function (){\n\tif (this._dom.firstChild) {\n\t\tvar el;\n\t\twhile (el = this._dom.firstChild){\n\t\t\ttrue && Imba.TagManager.remove(el._tag || el,this);\n\t\t\tthis._dom.removeChild(el);\n\t\t};\n\t};\n\tthis._tree_ = this._text_ = null;\n\treturn this;\n};\n\n/*\n\tAppend a single item (node or string) to the current node.\n\tIf supplied item is a string it will automatically. This is used\n\tby Imba internally, but will practically never be used explicitly.\n\t@return {self}\n\t*/\n\nImba.Tag.prototype.appendChild = function (node){\n\tif ((typeof node=='string'||node instanceof String)) {\n\t\tthis.dom().appendChild(Imba.document().createTextNode(node));\n\t} else if (node) {\n\t\tthis.dom().appendChild(node._slot_ || node);\n\t\tImba.TagManager.insert(node._tag || node,this);\n\t\t// FIXME ensure these are not called for text nodes\n\t};\n\treturn this;\n};\n\n/*\n\tInsert a node into the current node (self), before another.\n\tThe relative node must be a child of current node. \n\t*/\n\nImba.Tag.prototype.insertBefore = function (node,rel){\n\tif ((typeof node=='string'||node instanceof String)) {\n\t\tnode = Imba.document().createTextNode(node);\n\t};\n\t\n\tif (node && rel) {\n\t\tthis.dom().insertBefore((node._slot_ || node),(rel._slot_ || rel));\n\t\tImba.TagManager.insert(node._tag || node,this);\n\t\t// FIXME ensure these are not called for text nodes\n\t};\n\treturn this;\n};\n\nImba.Tag.prototype.detachFromParent = function (){\n\tif (this._slot_ == this._dom) {\n\t\tthis._slot_ = (this._dom._placeholder_ || (this._dom._placeholder_ = Imba.document().createComment(\"node\")));\n\t\tthis._slot_._tag || (this._slot_._tag = this);\n\t\t\n\t\tif (this._dom.parentNode) {\n\t\t\tImba.TagManager.remove(this,this._dom.parentNode);\n\t\t\tthis._dom.parentNode.replaceChild(this._slot_,this._dom);\n\t\t};\n\t};\n\treturn this;\n};\n\nImba.Tag.prototype.attachToParent = function (){\n\tif (this._slot_ != this._dom) {\n\t\tlet prev = this._slot_;\n\t\tthis._slot_ = this._dom;\n\t\tif (prev && prev.parentNode) {\n\t\t\tImba.TagManager.insert(this);\n\t\t\tprev.parentNode.replaceChild(this._dom,prev);\n\t\t};\n\t};\n\t\n\treturn this;\n};\n\n/*\n\tRemove node from the dom tree\n\t@return {self}\n\t*/\n\nImba.Tag.prototype.orphanize = function (){\n\tvar par;\n\tif (par = this.parent()) { par.removeChild(this) };\n\treturn this;\n};\n\n/*\n\tGet text of node. Uses textContent behind the scenes (not innerText)\n\t[https://developer.mozilla.org/en-US/docs/Web/API/Node/textContent]()\n\t@return {string} inner text of node\n\t*/\n\nImba.Tag.prototype.text = function (v){\n\treturn this._dom.textContent;\n};\n\n/*\n\tSet text of node. Uses textContent behind the scenes (not innerText)\n\t[https://developer.mozilla.org/en-US/docs/Web/API/Node/textContent]()\n\t*/\n\nImba.Tag.prototype.setText = function (txt){\n\tthis._tree_ = txt;\n\tthis._dom.textContent = (txt == null || this.text() === false) ? '' : txt;\n\tthis;\n\treturn this;\n};\n\n\n/*\n\tMethod for getting and setting data-attributes. When called with zero\n\targuments it will return the actual dataset for the tag.\n\n\t\tvar node = <div data-name='hello'>\n\t\t# get the whole dataset\n\t\tnode.dataset # {name: 'hello'}\n\t\t# get a single value\n\t\tnode.dataset('name') # 'hello'\n\t\t# set a single value\n\t\tnode.dataset('name','newname') # self\n\n\n\t*/\n\nImba.Tag.prototype.dataset = function (key,val){\n\tif (key instanceof Object) {\n\t\tfor (let v, i = 0, keys = Object.keys(key), l = keys.length, k; i < l; i++){\n\t\t\tk = keys[i];v = key[k];this.dataset(k,v);\n\t\t};\n\t\treturn this;\n\t};\n\t\n\tif (arguments.length == 2) {\n\t\tthis.setAttribute((\"data-\" + key),val);\n\t\treturn this;\n\t};\n\t\n\tif (key) {\n\t\treturn this.getAttribute((\"data-\" + key));\n\t};\n\t\n\tvar dataset = this.dom().dataset;\n\t\n\tif (!dataset) {\n\t\tdataset = {};\n\t\tfor (let i = 0, items = iter$(this.dom().attributes), len = items.length, atr; i < len; i++) {\n\t\t\tatr = items[i];\n\t\t\tif (atr.name.substr(0,5) == 'data-') {\n\t\t\t\tdataset[Imba.toCamelCase(atr.name.slice(5))] = atr.value;\n\t\t\t};\n\t\t};\n\t};\n\t\n\treturn dataset;\n};\n\n/*\n\tEmpty placeholder. Override to implement custom render behaviour.\n\tWorks much like the familiar render-method in React.\n\t@return {self}\n\t*/\n\nImba.Tag.prototype.render = function (){\n\treturn this;\n};\n\n/*\n\tCalled implicitly while tag is initializing. No initial props\n\twill have been set at this point.\n\t@return {self}\n\t*/\n\nImba.Tag.prototype.build = function (){\n\treturn this;\n};\n\n/*\n\tCalled once, implicitly through Imba.Tag#end. All initial props\n\tand children will have been set before setup is called.\n\tsetContent.\n\t@return {self}\n\t*/\n\nImba.Tag.prototype.setup = function (){\n\treturn this;\n};\n\n/*\n\tCalled implicitly through Imba.Tag#end, for tags that are part of\n\ta tag tree (that are rendered several times).\n\t@return {self}\n\t*/\n\nImba.Tag.prototype.commit = function (){\n\tif (this.beforeRender() !== false) this.render();\n\treturn this;\n};\n\nImba.Tag.prototype.beforeRender = function (){\n\treturn this;\n};\n\n/*\n\n\tCalled by the tag-scheduler (if this tag is scheduled)\n\tBy default it will call this.render. Do not override unless\n\tyou really understand it.\n\n\t*/\n\nImba.Tag.prototype.tick = function (){\n\tif (this.beforeRender() !== false) this.render();\n\treturn this;\n};\n\n/*\n\t\n\tA very important method that you will practically never manually.\n\tThe tag syntax of Imba compiles to a chain of setters, which always\n\tends with .end. `<a.large>` compiles to `tag('a').flag('large').end()`\n\t\n\tYou are highly adviced to not override its behaviour. The first time\n\tend is called it will mark the tag as initialized and call Imba.Tag#setup,\n\tand call Imba.Tag#commit every time.\n\t@return {self}\n\t*/\n\nImba.Tag.prototype.end = function (){\n\tthis.setup();\n\tthis.commit(0);\n\tthis.end = Imba.Tag.end;\n\treturn this;\n};\n\n// called on <self> to check if self is called from other places\nImba.Tag.prototype.$open = function (context){\n\tif (context != this._context_) {\n\t\tthis._tree_ = null;\n\t\tthis._context_ = context;\n\t};\n\treturn this;\n};\n\n/*\n\tThis is called instead of Imba.Tag#end for `<self>` tag chains.\n\tDefaults to noop\n\t@return {self}\n\t*/\n\nImba.Tag.prototype.synced = function (){\n\treturn this;\n};\n\n// called when the node is awakened in the dom - either automatically\n// upon attachment to the dom-tree, or the first time imba needs the\n// tag for a domnode that has been rendered on the server\nImba.Tag.prototype.awaken = function (){\n\treturn this;\n};\n\n/*\n\tList of flags for this node. \n\t*/\n\nImba.Tag.prototype.flags = function (){\n\treturn this._dom.classList;\n};\n\n/*\n\tAdd speficied flag to current node.\n\tIf a second argument is supplied, it will be coerced into a Boolean,\n\tand used to indicate whether we should remove the flag instead.\n\t@return {self}\n\t*/\n\nImba.Tag.prototype.flag = function (name,toggler){\n\t// it is most natural to treat a second undefined argument as a no-switch\n\t// so we need to check the arguments-length\n\tif (arguments.length == 2) {\n\t\tif (this._dom.classList.contains(name) != !!toggler) {\n\t\t\tthis._dom.classList.toggle(name);\n\t\t};\n\t} else {\n\t\t// firefox will trigger a change if adding existing class\n\t\tif (!this._dom.classList.contains(name)) { this._dom.classList.add(name) };\n\t};\n\treturn this;\n};\n\n/*\n\tRemove specified flag from node\n\t@return {self}\n\t*/\n\nImba.Tag.prototype.unflag = function (name){\n\tthis._dom.classList.remove(name);\n\treturn this;\n};\n\n/*\n\tToggle specified flag on node\n\t@return {self}\n\t*/\n\nImba.Tag.prototype.toggleFlag = function (name){\n\tthis._dom.classList.toggle(name);\n\treturn this;\n};\n\n/*\n\tCheck whether current node has specified flag\n\t@return {bool}\n\t*/\n\nImba.Tag.prototype.hasFlag = function (name){\n\treturn this._dom.classList.contains(name);\n};\n\n\nImba.Tag.prototype.flagIf = function (flag,bool){\n\tvar f = this._flags_ || (this._flags_ = {});\n\tlet prev = f[flag];\n\t\n\tif (bool && !prev) {\n\t\tthis._dom.classList.add(flag);\n\t\tf[flag] = true;\n\t} else if (prev && !bool) {\n\t\tthis._dom.classList.remove(flag);\n\t\tf[flag] = false;\n\t};\n\t\n\treturn this;\n};\n\n/*\n\tSet/update a named flag. It remembers the previous\n\tvalue of the flag, and removes it before setting the new value.\n\n\t\tnode.setFlag('type','todo')\n\t\tnode.setFlag('type','project')\n\t\t# todo is removed, project is added.\n\n\t@return {self}\n\t*/\n\nImba.Tag.prototype.setFlag = function (name,value){\n\tlet flags = this._namedFlags_ || (this._namedFlags_ = {});\n\tlet prev = flags[name];\n\tif (prev != value) {\n\t\tif (prev) { this.unflag(prev) };\n\t\tif (value) { this.flag(value) };\n\t\tflags[name] = value;\n\t};\n\treturn this;\n};\n\n\n/*\n\tGet the scheduler for this node. A new scheduler will be created\n\tif it does not already exist.\n\n\t@return {Imba.Scheduler}\n\t*/\n\nImba.Tag.prototype.scheduler = function (){\n\treturn (this._scheduler == null) ? (this._scheduler = new Imba.Scheduler(this)) : this._scheduler;\n};\n\n/*\n\n\tShorthand to start scheduling a node. The method will basically\n\tproxy the arguments through to scheduler.configure, and then\n\tactivate the scheduler.\n\t\n\t@return {self}\n\t*/\n\nImba.Tag.prototype.schedule = function (options){\n\tif(options === undefined) options = {events: true};\n\tthis.scheduler().configure(options).activate();\n\treturn this;\n};\n\n/*\n\tShorthand for deactivating scheduler (if tag has one).\n\t@deprecated\n\t*/\n\nImba.Tag.prototype.unschedule = function (){\n\tif (this._scheduler) { this.scheduler().deactivate() };\n\treturn this;\n};\n\n\n/*\n\tGet the parent of current node\n\t@return {Imba.Tag} \n\t*/\n\nImba.Tag.prototype.parent = function (){\n\treturn Imba.getTagForDom(this.dom().parentNode);\n};\n\n/*\n\tGet the children of node\n\t@return {Imba.Tag[]}\n\t*/\n\nImba.Tag.prototype.children = function (sel){\n\tlet res = [];\n\tfor (let i = 0, items = iter$(this._dom.children), len = items.length, item; i < len; i++) {\n\t\titem = items[i];\n\t\tres.push(item._tag || Imba.getTagForDom(item));\n\t};\n\treturn res;\n};\n\nImba.Tag.prototype.querySelector = function (q){\n\treturn Imba.getTagForDom(this._dom.querySelector(q));\n};\n\nImba.Tag.prototype.querySelectorAll = function (q){\n\tvar items = [];\n\tfor (let i = 0, ary = iter$(this._dom.querySelectorAll(q)), len = ary.length; i < len; i++) {\n\t\titems.push(Imba.getTagForDom(ary[i]));\n\t};\n\treturn items;\n};\n\n/*\n\tCheck if this node matches a selector\n\t@return {Boolean}\n\t*/\n\nImba.Tag.prototype.matches = function (sel){\n\tvar fn;\n\tif (sel instanceof Function) {\n\t\treturn sel(this);\n\t};\n\t\n\tif (sel.query instanceof Function) { sel = sel.query() };\n\tif (fn = (this._dom.matches || this._dom.matchesSelector || this._dom.webkitMatchesSelector || this._dom.msMatchesSelector || this._dom.mozMatchesSelector)) {\n\t\treturn fn.call(this._dom,sel);\n\t};\n};\n\n/*\n\tGet the first element matching supplied selector / filter\n\ttraversing upwards, but including the node itself.\n\t@return {Imba.Tag}\n\t*/\n\nImba.Tag.prototype.closest = function (sel){\n\treturn Imba.getTagForDom(this._dom.closest(sel));\n};\n\n/*\n\tCheck if node contains other node\n\t@return {Boolean} \n\t*/\n\nImba.Tag.prototype.contains = function (node){\n\treturn this.dom().contains(node._dom || node);\n};\n\n\n/*\n\tShorthand for console.log on elements\n\t@return {self}\n\t*/\n\nImba.Tag.prototype.log = function (){\n\tvar $0 = arguments, i = $0.length;\n\tvar args = new Array(i>0 ? i : 0);\n\twhile(i>0) args[i-1] = $0[--i];\n\targs.unshift(console);\n\tFunction.prototype.call.apply(console.log,args);\n\treturn this;\n};\n\nImba.Tag.prototype.css = function (key,val){\n\tif (key instanceof Object) {\n\t\tfor (let v, i = 0, keys = Object.keys(key), l = keys.length, k; i < l; i++){\n\t\t\tk = keys[i];v = key[k];this.css(k,v);\n\t\t};\n\t\treturn this;\n\t};\n\t\n\tvar name = Imba.CSSKeyMap[key] || key;\n\t\n\tif (val == null) {\n\t\tthis.dom().style.removeProperty(name);\n\t} else if (val == undefined && arguments.length == 1) {\n\t\treturn this.dom().style[name];\n\t} else {\n\t\tif ((typeof val=='number'||val instanceof Number) && name.match(/width|height|left|right|top|bottom/)) {\n\t\t\tthis.dom().style[name] = val + \"px\";\n\t\t} else {\n\t\t\tthis.dom().style[name] = val;\n\t\t};\n\t};\n\treturn this;\n};\n\nImba.Tag.prototype.setStyle = function (style){\n\treturn this.setAttribute('style',style);\n};\n\nImba.Tag.prototype.style = function (){\n\treturn this.getAttribute('style');\n};\n\n/*\n\tTrigger an event from current node. Dispatched through the Imba event manager.\n\tTo dispatch actual dom events, use dom.dispatchEvent instead.\n\n\t@return {Imba.Event}\n\t*/\n\nImba.Tag.prototype.trigger = function (name,data){\n\tif(data === undefined) data = {};\n\treturn true && Imba.Events.trigger(name,this,{data: data});\n};\n\n/*\n\tFocus on current node\n\t@return {self}\n\t*/\n\nImba.Tag.prototype.focus = function (){\n\tthis.dom().focus();\n\treturn this;\n};\n\n/*\n\tRemove focus from current node\n\t@return {self}\n\t*/\n\nImba.Tag.prototype.blur = function (){\n\tthis.dom().blur();\n\treturn this;\n};\n\nImba.Tag.prototype.toString = function (){\n\treturn this.dom().outerHTML;\n};\n\n\nImba.Tag.prototype.initialize = Imba.Tag;\n\nImba.SVGTag = function SVGTag(){ return Imba.Tag.apply(this,arguments) };\n\nImba.subclass(Imba.SVGTag,Imba.Tag);\nImba.SVGTag.namespaceURI = function (){\n\treturn \"http://www.w3.org/2000/svg\";\n};\n\nImba.SVGTag.buildNode = function (){\n\tvar dom = Imba.document().createElementNS(this.namespaceURI(),this._nodeType);\n\tif (this._classes) {\n\t\tvar cls = this._classes.join(\" \");\n\t\tif (cls) { dom.className.baseVal = cls };\n\t};\n\treturn dom;\n};\n\nImba.SVGTag.inherit = function (child){\n\tchild._protoDom = null;\n\t\n\tif (Imba.indexOf(child._name,Imba.SVG_TAGS) >= 0 || this == Imba.SVGTag) {\n\t\tchild._nodeType = child._name;\n\t\treturn child._classes = [];\n\t} else {\n\t\tchild._nodeType = this._nodeType;\n\t\tvar className = \"_\" + child._name.replace(/_/g,'-');\n\t\treturn child._classes = (this._classes || []).concat(className);\n\t};\n};\n\nImba.HTML_TAGS = \"a abbr address area article aside audio b base bdi bdo big blockquote body br button canvas caption cite code col colgroup data datalist dd del details dfn div dl dt em embed fieldset figcaption figure footer form h1 h2 h3 h4 h5 h6 head header hr html i iframe img input ins kbd keygen label legend li link main map mark menu menuitem meta meter nav noscript object ol optgroup option output p param pre progress q rp rt ruby s samp script section select small source span strong style sub summary sup table tbody td textarea tfoot th thead time title tr track u ul var video wbr\".split(\" \");\nImba.HTML_TAGS_UNSAFE = \"article aside header section\".split(\" \");\nImba.SVG_TAGS = \"circle defs ellipse g line linearGradient mask path pattern polygon polyline radialGradient rect stop svg text tspan image\".split(\" \");\n\nImba.HTML_ATTRS = {\n\ta: \"href target hreflang media download rel type\",\n\tform: \"method action enctype autocomplete target\",\n\tbutton: \"autofocus type\",\n\tinput: \"accept disabled form list max maxlength min pattern required size step type\",\n\tlabel: \"accesskey for form\",\n\timg: \"src srcset\",\n\tlink: \"rel type href media\",\n\tiframe: \"referrerpolicy src srcdoc sandbox\",\n\tmeta: \"property content charset desc\",\n\toptgroup: \"label\",\n\toption: \"label\",\n\toutput: \"for form\",\n\tobject: \"type data width height\",\n\tparam: \"name value\",\n\tprogress: \"max\",\n\tscript: \"src type async defer crossorigin integrity nonce language\",\n\tselect: \"size form multiple\",\n\ttextarea: \"rows cols\"\n};\n\n\nImba.HTML_PROPS = {\n\tinput: \"autofocus autocomplete autocorrect value placeholder required disabled multiple checked readOnly\",\n\ttextarea: \"autofocus autocomplete autocorrect value placeholder required disabled multiple checked readOnly\",\n\tform: \"novalidate\",\n\tfieldset: \"disabled\",\n\tbutton: \"disabled\",\n\tselect: \"autofocus disabled required\",\n\toption: \"disabled selected value\",\n\toptgroup: \"disabled\",\n\tprogress: \"value\",\n\tfieldset: \"disabled\",\n\tcanvas: \"width height\"\n};\n\nfunction extender(obj,sup){\n\tfor (let v, i = 0, keys = Object.keys(sup), l = keys.length, k; i < l; i++){\n\t\tk = keys[i];v = sup[k];(obj[k] == null) ? (obj[k] = v) : obj[k];\n\t};\n\t\n\tobj.prototype = Object.create(sup.prototype);\n\tobj.__super__ = obj.prototype.__super__ = sup.prototype;\n\tobj.prototype.constructor = obj;\n\tif (sup.inherit) { sup.inherit(obj) };\n\treturn obj;\n};\n\nfunction Tag(){\n\treturn function(dom,ctx) {\n\t\tthis.initialize(dom,ctx);\n\t\treturn this;\n\t};\n};\n\nfunction TagSpawner(type){\n\treturn function(zone) { return type.build(zone); };\n};\n\n\nImba.Tags = function Tags(){\n\tthis;\n};\n\nImba.Tags.prototype.__clone = function (ns){\n\tvar clone = Object.create(this);\n\tclone._parent = this;\n\treturn clone;\n};\n\nImba.Tags.prototype.ns = function (name){\n\treturn this['_' + name.toUpperCase()] || this.defineNamespace(name);\n};\n\nImba.Tags.prototype.defineNamespace = function (name){\n\tvar clone = Object.create(this);\n\tclone._parent = this;\n\tclone._ns = name;\n\tthis['_' + name.toUpperCase()] = clone;\n\treturn clone;\n};\n\nImba.Tags.prototype.baseType = function (name,ns){\n\treturn (Imba.indexOf(name,Imba.HTML_TAGS) >= 0) ? 'element' : 'div';\n};\n\nImba.Tags.prototype.defineTag = function (fullName,supr,body){\n\tif(body==undefined && typeof supr == 'function') body = supr,supr = '';\n\tif(supr==undefined) supr = '';\n\tif (body && body._nodeType) {\n\t\tsupr = body;\n\t\tbody = null;\n\t};\n\t\n\tif (this[fullName]) {\n\t\tconsole.log(\"tag already exists?\",fullName);\n\t};\n\t\n\t// if it is namespaced\n\tvar ns;\n\tvar name = fullName;\n\tlet nsidx = name.indexOf(':');\n\tif (nsidx >= 0) {\n\t\tns = fullName.substr(0,nsidx);\n\t\tname = fullName.substr(nsidx + 1);\n\t\tif (ns == 'svg' && !supr) {\n\t\t\tsupr = 'svg:element';\n\t\t};\n\t};\n\t\n\tsupr || (supr = this.baseType(fullName));\n\t\n\tlet supertype = ((typeof supr=='string'||supr instanceof String)) ? this.findTagType(supr) : supr;\n\tlet tagtype = Tag();\n\t\n\ttagtype._name = name;\n\ttagtype._flagName = null;\n\t\n\tif (name[0] == '#') {\n\t\tImba.SINGLETONS[name.slice(1)] = tagtype;\n\t\tthis[name] = tagtype;\n\t} else if (name[0] == name[0].toUpperCase()) {\n\t\ttagtype._flagName = name;\n\t} else {\n\t\ttagtype._flagName = \"_\" + fullName.replace(/[_\\:]/g,'-');\n\t\tthis[fullName] = tagtype;\n\t};\n\t\n\textender(tagtype,supertype);\n\t\n\tif (body) {\n\t\tbody.call(tagtype,tagtype,tagtype.TAGS || this);\n\t\tif (tagtype.defined) { tagtype.defined() };\n\t\tthis.optimizeTag(tagtype);\n\t};\n\treturn tagtype;\n};\n\nImba.Tags.prototype.defineSingleton = function (name,supr,body){\n\treturn this.defineTag(name,supr,body);\n};\n\nImba.Tags.prototype.extendTag = function (name,supr,body){\n\tif(body==undefined && typeof supr == 'function') body = supr,supr = '';\n\tif(supr==undefined) supr = '';\n\tvar klass = (((typeof name=='string'||name instanceof String)) ? this.findTagType(name) : name);\n\t// allow for private tags here as well?\n\tif (body) { body && body.call(klass,klass,klass.prototype) };\n\tif (klass.extended) { klass.extended() };\n\tthis.optimizeTag(klass);\n\treturn klass;\n};\n\nImba.Tags.prototype.optimizeTag = function (tagtype){\n\tvar prototype_;\n\treturn (prototype_ = tagtype.prototype) && prototype_.optimizeTagStructure  &&  prototype_.optimizeTagStructure();\n};\n\nImba.Tags.prototype.findTagType = function (type){\n\tvar attrs, props;\n\tlet klass = this[type];\n\tif (!klass) {\n\t\tif (type.substr(0,4) == 'svg:') {\n\t\t\tklass = this.defineTag(type,'svg:element');\n\t\t} else if (Imba.HTML_TAGS.indexOf(type) >= 0) {\n\t\t\tklass = this.defineTag(type,'element');\n\t\t\t\n\t\t\tif (attrs = Imba.HTML_ATTRS[type]) {\n\t\t\t\tfor (let i = 0, items = iter$(attrs.split(\" \")), len = items.length; i < len; i++) {\n\t\t\t\t\tImba.attr(klass,items[i]);\n\t\t\t\t};\n\t\t\t};\n\t\t\t\n\t\t\tif (props = Imba.HTML_PROPS[type]) {\n\t\t\t\tfor (let i = 0, items = iter$(props.split(\" \")), len = items.length; i < len; i++) {\n\t\t\t\t\tImba.attr(klass,items[i],{dom: true});\n\t\t\t\t};\n\t\t\t};\n\t\t};\n\t};\n\treturn klass;\n};\n\nImba.Tags.prototype.createElement = function (name,owner){\n\tvar typ;\n\tif (name instanceof Function) {\n\t\ttyp = name;\n\t} else {\n\t\tif (null) {};\n\t\ttyp = this.findTagType(name);\n\t};\n\treturn typ.build(owner);\n};\n\n\nImba.createElement = function (name,ctx,ref,pref){\n\tvar type = name;\n\tvar parent;\n\tif (name instanceof Function) {\n\t\ttype = name;\n\t} else {\n\t\tif (null) {};\n\t\ttype = Imba.TAGS.findTagType(name);\n\t};\n\t\n\tif (ctx instanceof TagMap) {\n\t\tparent = ctx.par$;\n\t} else if (pref instanceof Imba.Tag) {\n\t\tparent = pref;\n\t} else {\n\t\tparent = (ctx && pref != undefined) ? ctx[pref] : ((ctx && ctx._tag || ctx));\n\t};\n\t\n\tvar node = type.build(parent);\n\t\n\tif (ctx instanceof TagMap) {\n\t\tctx.i$++;\n\t\tnode.$key = ref;\n\t};\n\t\n\t// node:$ref = ref if ref\n\t// context:i$++ # only if it is not an array?\n\tif (ctx && ref != undefined) {\n\t\tctx[ref] = node;\n\t};\n\t\n\treturn node;\n};\n\nImba.createTagCache = function (owner){\n\tvar item = [];\n\titem._tag = owner;\n\treturn item;\n\t\n\tvar par = ((this.pref() != undefined) ? this.ctx()[this.pref()] : this.ctx()._tag);\n\tvar node = new TagMap(this.ctx(),this.ref(),par);\n\tthis.ctx()[this.ref()] = node;\n\treturn node;\n};\n\nImba.createTagMap = function (ctx,ref,pref){\n\tvar par = ((pref != undefined) ? pref : ctx._tag);\n\tvar node = new TagMap(ctx,ref,par);\n\tctx[ref] = node;\n\treturn node;\n};\n\nImba.createTagList = function (ctx,ref,pref){\n\tvar node = [];\n\tnode._type = 4;\n\tnode._tag = ((pref != undefined) ? pref : ctx._tag);\n\tctx[ref] = node;\n\treturn node;\n};\n\nImba.createTagLoopResult = function (ctx,ref,pref){\n\tvar node = [];\n\tnode._type = 5;\n\tnode.cache = {i$: 0};\n\treturn node;\n};\n\n// use array instead?\nfunction TagCache(owner){\n\tthis._tag = owner;\n\tthis;\n};\nTagCache.build = function (owner){\n\tvar item = [];\n\titem._tag = owner;\n\treturn item;\n};\n\n\n\nfunction TagMap(cache,ref,par){\n\tthis.cache$ = cache;\n\tthis.key$ = ref;\n\tthis.par$ = par;\n\tthis.i$ = 0;\n\t// self:curr$ = self:$iternew()\n\t// self:next$ = self:$iternew()\n};\n\nTagMap.prototype.$iter = function (){\n\tvar item = [];\n\titem._type = 5;\n\titem.cache = this;\n\treturn item;\n};\n\nTagMap.prototype.$prune = function (items){\n\tlet cache = this.cache$;\n\tlet key = this.key$;\n\tlet clone = new TagMap(cache,key,this.par$);\n\tfor (let i = 0, ary = iter$(items), len = ary.length, item; i < len; i++) {\n\t\titem = ary[i];\n\t\tclone[item.key$] = item;\n\t};\n\tclone.i$ = items.length;\n\treturn cache[key] = clone;\n};\n\nImba.TagMap = TagMap;\nImba.TagCache = TagCache;\nImba.SINGLETONS = {};\nImba.TAGS = new Imba.Tags();\nImba.TAGS.element = Imba.TAGS.htmlelement = Imba.Tag;\nImba.TAGS['svg:element'] = Imba.SVGTag;\n\nImba.defineTag = function (name,supr,body){\n\tif(body==undefined && typeof supr == 'function') body = supr,supr = '';\n\tif(supr==undefined) supr = '';\n\treturn Imba.TAGS.defineTag(name,supr,body);\n};\n\nImba.defineSingletonTag = function (id,supr,body){\n\tif(body==undefined && typeof supr == 'function') body = supr,supr = 'div';\n\tif(supr==undefined) supr = 'div';\n\treturn Imba.TAGS.defineTag(this.name(),supr,body);\n};\n\nImba.extendTag = function (name,body){\n\treturn Imba.TAGS.extendTag(name,body);\n};\n\nImba.getTagSingleton = function (id){\n\tvar klass;\n\tvar dom,node;\n\t\n\tif (klass = Imba.SINGLETONS[id]) {\n\t\tif (klass && klass.Instance) { return klass.Instance };\n\t\t\n\t\t// no instance - check for element\n\t\tif (dom = Imba.document().getElementById(id)) {\n\t\t\t// we have a live instance - when finding it through a selector we should awake it, no?\n\t\t\t// console.log('creating the singleton from existing node in dom?',id,type)\n\t\t\tnode = klass.Instance = new klass(dom);\n\t\t\tnode.awaken(dom); // should only awaken\n\t\t\treturn node;\n\t\t};\n\t\t\n\t\tdom = klass.createNode();\n\t\tdom.id = id;\n\t\tnode = klass.Instance = new klass(dom);\n\t\tnode.end().awaken(dom);\n\t\treturn node;\n\t} else if (dom = Imba.document().getElementById(id)) {\n\t\treturn Imba.getTagForDom(dom);\n\t};\n};\n\nvar svgSupport = typeof SVGElement !== 'undefined';\n\n// shuold be phased out\nImba.getTagForDom = function (dom){\n\tif (!dom) { return null };\n\tif (dom._dom) { return dom }; // could use inheritance instead\n\tif (dom._tag) { return dom._tag };\n\tif (!dom.nodeName) { return null };\n\t\n\tvar name = dom.nodeName.toLowerCase();\n\tvar type = name;\n\tvar ns = Imba.TAGS; //  svgSupport and dom isa SVGElement ? Imba.TAGS:_SVG : Imba.TAGS\n\t\n\tif (dom.id && Imba.SINGLETONS[dom.id]) {\n\t\treturn Imba.getTagSingleton(dom.id);\n\t};\n\t\n\tif (svgSupport && (dom instanceof SVGElement)) {\n\t\ttype = ns.findTagType(\"svg:\" + name);\n\t} else if (Imba.HTML_TAGS.indexOf(name) >= 0) {\n\t\ttype = ns.findTagType(name);\n\t} else {\n\t\ttype = Imba.Tag;\n\t};\n\t// if ns.@nodeNames.indexOf(name) >= 0\n\t//\ttype = ns.findTagType(name)\n\t\n\treturn new type(dom,null).awaken(dom);\n};\n\n// deprecate\nImba.generateCSSPrefixes = function (){\n\tvar styles = window.getComputedStyle(document.documentElement,'');\n\t\n\tfor (let i = 0, items = iter$(styles), len = items.length, prefixed; i < len; i++) {\n\t\tprefixed = items[i];\n\t\tvar unprefixed = prefixed.replace(/^-(webkit|ms|moz|o|blink)-/,'');\n\t\tvar camelCase = unprefixed.replace(/-(\\w)/g,function(m,a) { return a.toUpperCase(); });\n\t\t\n\t\t// if there exists an unprefixed version -- always use this\n\t\tif (prefixed != unprefixed) {\n\t\t\tif (styles.hasOwnProperty(unprefixed)) { continue; };\n\t\t};\n\t\t\n\t\t// register the prefixes\n\t\tImba.CSSKeyMap[unprefixed] = Imba.CSSKeyMap[camelCase] = prefixed;\n\t};\n\treturn;\n};\n\nif (true) {\n\tif (document) { Imba.generateCSSPrefixes() };\n\t\n\t// Ovverride classList\n\tif (document && !document.documentElement.classList) {\n\t\tImba.extendTag('element', function(tag){\n\t\t\t\n\t\t\ttag.prototype.hasFlag = function (ref){\n\t\t\t\treturn new RegExp('(^|\\\\s)' + ref + '(\\\\s|$)').test(this._dom.className);\n\t\t\t};\n\t\t\t\n\t\t\ttag.prototype.addFlag = function (ref){\n\t\t\t\tif (this.hasFlag(ref)) { return this };\n\t\t\t\tthis._dom.className += (this._dom.className ? ' ' : '') + ref;\n\t\t\t\treturn this;\n\t\t\t};\n\t\t\t\n\t\t\ttag.prototype.unflag = function (ref){\n\t\t\t\tif (!this.hasFlag(ref)) { return this };\n\t\t\t\tvar regex = new RegExp('(^|\\\\s)*' + ref + '(\\\\s|$)*','g');\n\t\t\t\tthis._dom.className = this._dom.className.replace(regex,'');\n\t\t\t\treturn this;\n\t\t\t};\n\t\t\t\n\t\t\ttag.prototype.toggleFlag = function (ref){\n\t\t\t\treturn this.hasFlag(ref) ? this.unflag(ref) : this.flag(ref);\n\t\t\t};\n\t\t\t\n\t\t\ttag.prototype.flag = function (ref,bool){\n\t\t\t\tif (arguments.length == 2 && !!bool === false) {\n\t\t\t\t\treturn this.unflag(ref);\n\t\t\t\t};\n\t\t\t\treturn this.addFlag(ref);\n\t\t\t};\n\t\t});\n\t};\n};\n\nImba.Tag;\n\n\n//# sourceURL=webpack:///./node_modules/imba/src/imba/dom/tag.imba?");

/***/ }),

/***/ "./node_modules/imba/src/imba/dom/touch.imba":
/*!***************************************************!*\
  !*** ./node_modules/imba/src/imba/dom/touch.imba ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };\nvar Imba = __webpack_require__(/*! ../imba */ \"./node_modules/imba/src/imba/imba.imba\");\n\n// Imba.Touch\n// Began\tA finger touched the screen.\n// Moved\tA finger moved on the screen.\n// Stationary\tA finger is touching the screen but hasn't moved.\n// Ended\tA finger was lifted from the screen. This is the final phase of a touch.\n// Canceled The system cancelled tracking for the touch.\n\n/*\nConsolidates mouse and touch events. Touch objects persist across a touch,\nfrom touchstart until end/cancel. When a touch starts, it will traverse\ndown from the innermost target, until it finds a node that responds to\nontouchstart. Unless the touch is explicitly redirected, the touch will\ncall ontouchmove and ontouchend / ontouchcancel on the responder when appropriate.\n\n\ttag draggable\n\t\t# called when a touch starts\n\t\tdef ontouchstart touch\n\t\t\tflag 'dragging'\n\t\t\tself\n\t\t\n\t\t# called when touch moves - same touch object\n\t\tdef ontouchmove touch\n\t\t\t# move the node with touch\n\t\t\tcss top: touch.dy, left: touch.dx\n\t\t\n\t\t# called when touch ends\n\t\tdef ontouchend touch\n\t\t\tunflag 'dragging'\n\n@iname touch\n*/\n\nImba.Touch = function Touch(event,pointer){\n\t// @native  = false\n\tthis.setEvent(event);\n\tthis.setData({});\n\tthis.setActive(true);\n\tthis._button = event && event.button || 0;\n\tthis._suppress = false; // deprecated\n\tthis._captured = false;\n\tthis.setBubble(false);\n\tpointer = pointer;\n\tthis.setUpdates(0);\n\treturn this;\n};\n\nImba.Touch.LastTimestamp = 0;\nImba.Touch.TapTimeout = 50;\n\n// var lastNativeTouchTimeout = 50\n\nvar touches = [];\nvar count = 0;\nvar identifiers = {};\n\nImba.Touch.count = function (){\n\treturn count;\n};\n\nImba.Touch.lookup = function (item){\n\treturn item && (item.__touch__ || identifiers[item.identifier]);\n};\n\nImba.Touch.release = function (item,touch){\n\tvar v_, $1;\n\t(((v_ = identifiers[item.identifier]),delete identifiers[item.identifier], v_));\n\t((($1 = item.__touch__),delete item.__touch__, $1));\n\treturn;\n};\n\nImba.Touch.ontouchstart = function (e){\n\tfor (let i = 0, items = iter$(e.changedTouches), len = items.length, t; i < len; i++) {\n\t\tt = items[i];\n\t\tif (this.lookup(t)) { continue; };\n\t\tvar touch = identifiers[t.identifier] = new this(e); // (e)\n\t\tt.__touch__ = touch;\n\t\ttouches.push(touch);\n\t\tcount++;\n\t\ttouch.touchstart(e,t);\n\t};\n\treturn this;\n};\n\nImba.Touch.ontouchmove = function (e){\n\tvar touch;\n\tfor (let i = 0, items = iter$(e.changedTouches), len = items.length, t; i < len; i++) {\n\t\tt = items[i];\n\t\tif (touch = this.lookup(t)) {\n\t\t\ttouch.touchmove(e,t);\n\t\t};\n\t};\n\t\n\treturn this;\n};\n\nImba.Touch.ontouchend = function (e){\n\tvar touch;\n\tfor (let i = 0, items = iter$(e.changedTouches), len = items.length, t; i < len; i++) {\n\t\tt = items[i];\n\t\tif (touch = this.lookup(t)) {\n\t\t\ttouch.touchend(e,t);\n\t\t\tthis.release(t,touch);\n\t\t\tcount--;\n\t\t};\n\t};\n\t\n\t// e.preventDefault\n\t// not always supported!\n\t// touches = touches.filter(||)\n\treturn this;\n};\n\nImba.Touch.ontouchcancel = function (e){\n\tvar touch;\n\tfor (let i = 0, items = iter$(e.changedTouches), len = items.length, t; i < len; i++) {\n\t\tt = items[i];\n\t\tif (touch = this.lookup(t)) {\n\t\t\ttouch.touchcancel(e,t);\n\t\t\tthis.release(t,touch);\n\t\t\tcount--;\n\t\t};\n\t};\n\treturn this;\n};\n\nImba.Touch.onmousedown = function (e){\n\treturn this;\n};\n\nImba.Touch.onmousemove = function (e){\n\treturn this;\n};\n\nImba.Touch.onmouseup = function (e){\n\treturn this;\n};\n\n\nImba.Touch.prototype.phase = function(v){ return this._phase; }\nImba.Touch.prototype.setPhase = function(v){ this._phase = v; return this; };\nImba.Touch.prototype.active = function(v){ return this._active; }\nImba.Touch.prototype.setActive = function(v){ this._active = v; return this; };\nImba.Touch.prototype.event = function(v){ return this._event; }\nImba.Touch.prototype.setEvent = function(v){ this._event = v; return this; };\nImba.Touch.prototype.pointer = function(v){ return this._pointer; }\nImba.Touch.prototype.setPointer = function(v){ this._pointer = v; return this; };\nImba.Touch.prototype.target = function(v){ return this._target; }\nImba.Touch.prototype.setTarget = function(v){ this._target = v; return this; };\nImba.Touch.prototype.handler = function(v){ return this._handler; }\nImba.Touch.prototype.setHandler = function(v){ this._handler = v; return this; };\nImba.Touch.prototype.updates = function(v){ return this._updates; }\nImba.Touch.prototype.setUpdates = function(v){ this._updates = v; return this; };\nImba.Touch.prototype.suppress = function(v){ return this._suppress; }\nImba.Touch.prototype.setSuppress = function(v){ this._suppress = v; return this; };\nImba.Touch.prototype.data = function(v){ return this._data; }\nImba.Touch.prototype.setData = function(v){ this._data = v; return this; };\nImba.Touch.prototype.__bubble = {chainable: true,name: 'bubble'};\nImba.Touch.prototype.bubble = function(v){ return v !== undefined ? (this.setBubble(v),this) : this._bubble; }\nImba.Touch.prototype.setBubble = function(v){ this._bubble = v; return this; };\nImba.Touch.prototype.timestamp = function(v){ return this._timestamp; }\nImba.Touch.prototype.setTimestamp = function(v){ this._timestamp = v; return this; };\n\nImba.Touch.prototype.gestures = function(v){ return this._gestures; }\nImba.Touch.prototype.setGestures = function(v){ this._gestures = v; return this; };\n\n/*\n\t@internal\n\t@constructor\n\t*/\n\nImba.Touch.prototype.capture = function (){\n\tthis._captured = true;\n\tthis._event && this._event.stopPropagation();\n\tif (!this._selblocker) {\n\t\tthis._selblocker = function(e) { return e.preventDefault(); };\n\t\tImba.document().addEventListener('selectstart',this._selblocker,true);\n\t};\n\treturn this;\n};\n\nImba.Touch.prototype.isCaptured = function (){\n\treturn !!this._captured;\n};\n\n/*\n\tExtend the touch with a plugin / gesture. \n\tAll events (touchstart,move etc) for the touch\n\twill be triggered on the plugins in the order they\n\tare added.\n\t*/\n\nImba.Touch.prototype.extend = function (plugin){\n\t// console.log \"added gesture!!!\"\n\tthis._gestures || (this._gestures = []);\n\tthis._gestures.push(plugin);\n\treturn this;\n};\n\n/*\n\tRedirect touch to specified target. ontouchstart will always be\n\tcalled on the new target.\n\t@return {Number}\n\t*/\n\nImba.Touch.prototype.redirect = function (target){\n\tthis._redirect = target;\n\treturn this;\n};\n\n/*\n\tSuppress the default behaviour. Will call preventDefault for\n\tall native events that are part of the touch.\n\t*/\n\nImba.Touch.prototype.suppress = function (){\n\t// collision with the suppress property\n\tthis._active = false;\n\t\n\treturn this;\n};\n\nImba.Touch.prototype.setSuppress = function (value){\n\tconsole.warn('Imba.Touch#suppress= is deprecated');\n\tthis._supress = value;\n\tthis;\n\treturn this;\n};\n\nImba.Touch.prototype.touchstart = function (e,t){\n\tthis._event = e;\n\tthis._touch = t;\n\tthis._button = 0;\n\tthis._x = t.clientX;\n\tthis._y = t.clientY;\n\tthis.began();\n\tthis.update();\n\tif (e && this.isCaptured()) { e.preventDefault() };\n\treturn this;\n};\n\nImba.Touch.prototype.touchmove = function (e,t){\n\tthis._event = e;\n\tthis._x = t.clientX;\n\tthis._y = t.clientY;\n\tthis.update();\n\tif (e && this.isCaptured()) { e.preventDefault() };\n\treturn this;\n};\n\nImba.Touch.prototype.touchend = function (e,t){\n\tthis._event = e;\n\tthis._x = t.clientX;\n\tthis._y = t.clientY;\n\tthis.ended();\n\t\n\tImba.Touch.LastTimestamp = e.timeStamp;\n\t\n\tif (this._maxdr < 20) {\n\t\tvar tap = new Imba.Event(e);\n\t\ttap.setType('tap');\n\t\ttap.process();\n\t\tif (tap._responder) { e.preventDefault() };\n\t};\n\t\n\tif (e && this.isCaptured()) {\n\t\te.preventDefault();\n\t};\n\t\n\treturn this;\n};\n\nImba.Touch.prototype.touchcancel = function (e,t){\n\treturn this.cancel();\n};\n\nImba.Touch.prototype.mousedown = function (e,t){\n\tvar self = this;\n\tself._event = e;\n\tself._button = e.button;\n\tself._x = t.clientX;\n\tself._y = t.clientY;\n\tself.began();\n\tself.update();\n\tself._mousemove = function(e) { return self.mousemove(e,e); };\n\tImba.document().addEventListener('mousemove',self._mousemove,true);\n\treturn self;\n};\n\nImba.Touch.prototype.mousemove = function (e,t){\n\tthis._x = t.clientX;\n\tthis._y = t.clientY;\n\tthis._event = e;\n\tif (this.isCaptured()) { e.preventDefault() };\n\tthis.update();\n\tthis.move();\n\treturn this;\n};\n\nImba.Touch.prototype.mouseup = function (e,t){\n\tthis._x = t.clientX;\n\tthis._y = t.clientY;\n\tthis.ended();\n\treturn this;\n};\n\nImba.Touch.prototype.idle = function (){\n\treturn this.update();\n};\n\nImba.Touch.prototype.began = function (){\n\tthis._timestamp = Date.now();\n\tthis._maxdr = this._dr = 0;\n\tthis._x0 = this._x;\n\tthis._y0 = this._y;\n\t\n\tvar dom = this.event().target;\n\tvar node = null;\n\t\n\tthis._sourceTarget = dom && Imba.getTagForDom(dom);\n\t\n\twhile (dom){\n\t\tnode = Imba.getTagForDom(dom);\n\t\tif (node && node.ontouchstart) {\n\t\t\tthis._bubble = false;\n\t\t\tthis.setTarget(node);\n\t\t\tthis.target().ontouchstart(this);\n\t\t\tif (!this._bubble) { break; };\n\t\t};\n\t\tdom = dom.parentNode;\n\t};\n\t\n\tthis._updates++;\n\treturn this;\n};\n\nImba.Touch.prototype.update = function (){\n\tvar target_;\n\tif (!this._active || this._cancelled) { return this };\n\t\n\tvar dr = Math.sqrt(this.dx() * this.dx() + this.dy() * this.dy());\n\tif (dr > this._dr) { this._maxdr = dr };\n\tthis._dr = dr;\n\t\n\t// catching a touch-redirect?!?\n\tif (this._redirect) {\n\t\tif (this._target && this._target.ontouchcancel) {\n\t\t\tthis._target.ontouchcancel(this);\n\t\t};\n\t\tthis.setTarget(this._redirect);\n\t\tthis._redirect = null;\n\t\tif (this.target().ontouchstart) { this.target().ontouchstart(this) };\n\t\tif (this._redirect) { return this.update() }; // possibly redirecting again\n\t};\n\t\n\t\n\tthis._updates++;\n\tif (this._gestures) {\n\t\tfor (let i = 0, items = iter$(this._gestures), len = items.length; i < len; i++) {\n\t\t\titems[i].ontouchupdate(this);\n\t\t};\n\t};\n\t\n\t(target_ = this.target()) && target_.ontouchupdate  &&  target_.ontouchupdate(this);\n\tif (this._redirect) this.update();\n\treturn this;\n};\n\nImba.Touch.prototype.move = function (){\n\tvar target_;\n\tif (!this._active || this._cancelled) { return this };\n\t\n\tif (this._gestures) {\n\t\tfor (let i = 0, items = iter$(this._gestures), len = items.length, g; i < len; i++) {\n\t\t\tg = items[i];\n\t\t\tif (g.ontouchmove) { g.ontouchmove(this,this._event) };\n\t\t};\n\t};\n\t\n\t(target_ = this.target()) && target_.ontouchmove  &&  target_.ontouchmove(this,this._event);\n\treturn this;\n};\n\nImba.Touch.prototype.ended = function (){\n\tvar target_;\n\tif (!this._active || this._cancelled) { return this };\n\t\n\tthis._updates++;\n\t\n\tif (this._gestures) {\n\t\tfor (let i = 0, items = iter$(this._gestures), len = items.length; i < len; i++) {\n\t\t\titems[i].ontouchend(this);\n\t\t};\n\t};\n\t\n\t(target_ = this.target()) && target_.ontouchend  &&  target_.ontouchend(this);\n\tthis.cleanup_();\n\treturn this;\n};\n\nImba.Touch.prototype.cancel = function (){\n\tif (!this._cancelled) {\n\t\tthis._cancelled = true;\n\t\tthis.cancelled();\n\t\tthis.cleanup_();\n\t};\n\treturn this;\n};\n\nImba.Touch.prototype.cancelled = function (){\n\tvar target_;\n\tif (!this._active) { return this };\n\t\n\tthis._cancelled = true;\n\tthis._updates++;\n\t\n\tif (this._gestures) {\n\t\tfor (let i = 0, items = iter$(this._gestures), len = items.length, g; i < len; i++) {\n\t\t\tg = items[i];\n\t\t\tif (g.ontouchcancel) { g.ontouchcancel(this) };\n\t\t};\n\t};\n\t\n\t(target_ = this.target()) && target_.ontouchcancel  &&  target_.ontouchcancel(this);\n\treturn this;\n};\n\nImba.Touch.prototype.cleanup_ = function (){\n\tif (this._mousemove) {\n\t\tImba.document().removeEventListener('mousemove',this._mousemove,true);\n\t\tthis._mousemove = null;\n\t};\n\t\n\tif (this._selblocker) {\n\t\tImba.document().removeEventListener('selectstart',this._selblocker,true);\n\t\tthis._selblocker = null;\n\t};\n\t\n\treturn this;\n};\n\n/*\n\tThe absolute distance the touch has moved from starting position \n\t@return {Number}\n\t*/\n\nImba.Touch.prototype.dr = function (){\n\treturn this._dr;\n};\n\n/*\n\tThe distance the touch has moved horizontally\n\t@return {Number}\n\t*/\n\nImba.Touch.prototype.dx = function (){\n\treturn this._x - this._x0;\n};\n\n/*\n\tThe distance the touch has moved vertically\n\t@return {Number}\n\t*/\n\nImba.Touch.prototype.dy = function (){\n\treturn this._y - this._y0;\n};\n\n/*\n\tInitial horizontal position of touch\n\t@return {Number}\n\t*/\n\nImba.Touch.prototype.x0 = function (){\n\treturn this._x0;\n};\n\n/*\n\tInitial vertical position of touch\n\t@return {Number}\n\t*/\n\nImba.Touch.prototype.y0 = function (){\n\treturn this._y0;\n};\n\n/*\n\tHorizontal position of touch\n\t@return {Number}\n\t*/\n\nImba.Touch.prototype.x = function (){\n\treturn this._x;\n};\n\n/*\n\tVertical position of touch\n\t@return {Number}\n\t*/\n\nImba.Touch.prototype.y = function (){\n\treturn this._y;\n};\n\n/*\n\tHorizontal position of touch relative to target\n\t@return {Number}\n\t*/\n\nImba.Touch.prototype.tx = function (){\n\tthis._targetBox || (this._targetBox = this._target.dom().getBoundingClientRect());\n\treturn this._x - this._targetBox.left;\n};\n\n/*\n\tVertical position of touch relative to target\n\t@return {Number}\n\t*/\n\nImba.Touch.prototype.ty = function (){\n\tthis._targetBox || (this._targetBox = this._target.dom().getBoundingClientRect());\n\treturn this._y - this._targetBox.top;\n};\n\n/*\n\tButton pressed in this touch. Native touches defaults to left-click (0)\n\t@return {Number}\n\t*/\n\nImba.Touch.prototype.button = function (){\n\treturn this._button;\n}; // @pointer ? @pointer.button : 0\n\nImba.Touch.prototype.sourceTarget = function (){\n\treturn this._sourceTarget;\n};\n\nImba.Touch.prototype.elapsed = function (){\n\treturn Date.now() - this._timestamp;\n};\n\n\nImba.TouchGesture = function TouchGesture(){ };\n\nImba.TouchGesture.prototype.__active = {'default': false,name: 'active'};\nImba.TouchGesture.prototype.active = function(v){ return this._active; }\nImba.TouchGesture.prototype.setActive = function(v){ this._active = v; return this; }\nImba.TouchGesture.prototype._active = false;\n\nImba.TouchGesture.prototype.ontouchstart = function (e){\n\treturn this;\n};\n\nImba.TouchGesture.prototype.ontouchupdate = function (e){\n\treturn this;\n};\n\nImba.TouchGesture.prototype.ontouchend = function (e){\n\treturn this;\n};\n\n\n\n//# sourceURL=webpack:///./node_modules/imba/src/imba/dom/touch.imba?");

/***/ }),

/***/ "./node_modules/imba/src/imba/imba.imba":
/*!**********************************************!*\
  !*** ./node_modules/imba/src/imba/imba.imba ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*\nImba is the namespace for all runtime related utilities\n@namespace\n*/\n\nvar Imba = {VERSION: '1.3.3'};\n\n/*\n\nLight wrapper around native setTimeout that expects the block / function\nas last argument (instead of first). It also triggers an event to Imba\nafter the timeout to let schedulers update (to rerender etc) afterwards.\n\n*/\n\nImba.setTimeout = function (delay,block){\n\treturn setTimeout(function() {\n\t\tblock();\n\t\treturn Imba.commit();\n\t},delay);\n};\n\n/*\n\nLight wrapper around native setInterval that expects the block / function\nas last argument (instead of first). It also triggers an event to Imba\nafter every interval to let schedulers update (to rerender etc) afterwards.\n\n*/\n\nImba.setInterval = function (interval,block){\n\treturn setInterval(block,interval);\n};\n\n/*\nClear interval with specified id\n*/\n\nImba.clearInterval = function (id){\n\treturn clearInterval(id);\n};\n\n/*\nClear timeout with specified id\n*/\n\nImba.clearTimeout = function (id){\n\treturn clearTimeout(id);\n};\n\n\nImba.subclass = function (obj,sup){\n\tfor (let k in sup){\n\t\tlet v;\n\t\tv = sup[k];if (sup.hasOwnProperty(k)) { obj[k] = v };\n\t};\n\t\n\tobj.prototype = Object.create(sup.prototype);\n\tobj.__super__ = obj.prototype.__super__ = sup.prototype;\n\tobj.prototype.initialize = obj.prototype.constructor = obj;\n\treturn obj;\n};\n\n/*\nLightweight method for making an object iterable in imbas for/in loops.\nIf the compiler cannot say for certain that a target in a for loop is an\narray, it will cache the iterable version before looping.\n\n```imba\n# this is the whole method\ndef Imba.iterable o\n\treturn o ? (o:toArray ? o.toArray : o) : []\n\nclass CustomIterable\n\tdef toArray\n\t\t[1,2,3]\n\n# will return [2,4,6]\nfor x in CustomIterable.new\n\tx * 2\n\n```\n*/\n\nImba.iterable = function (o){\n\treturn o ? ((o.toArray ? o.toArray() : o)) : [];\n};\n\n/*\nCoerces a value into a promise. If value is array it will\ncall `Promise.all(value)`, or if it is not a promise it will\nwrap the value in `Promise.resolve(value)`. Used for experimental\nawait syntax.\n@return {Promise}\n*/\n\nImba.await = function (value){\n\tif (value instanceof Array) {\n\t\tconsole.warn(\"await (Array) is deprecated - use await Promise.all(Array)\");\n\t\treturn Promise.all(value);\n\t} else if (value && value.then) {\n\t\treturn value;\n\t} else {\n\t\treturn Promise.resolve(value);\n\t};\n};\n\nvar dashRegex = /-./g;\nvar setterCache = {};\n\nImba.toCamelCase = function (str){\n\tif (str.indexOf('-') >= 0) {\n\t\treturn str.replace(dashRegex,function(m) { return m.charAt(1).toUpperCase(); });\n\t} else {\n\t\treturn str;\n\t};\n};\n\nImba.toSetter = function (str){\n\treturn setterCache[str] || (setterCache[str] = Imba.toCamelCase('set-' + str));\n};\n\nImba.indexOf = function (a,b){\n\treturn (b && b.indexOf) ? b.indexOf(a) : [].indexOf.call(a,b);\n};\n\nImba.len = function (a){\n\treturn a && ((a.len instanceof Function) ? a.len.call(a) : a.length) || 0;\n};\n\nImba.prop = function (scope,name,opts){\n\tif (scope.defineProperty) {\n\t\treturn scope.defineProperty(name,opts);\n\t};\n\treturn;\n};\n\nImba.attr = function (scope,name,opts){\n\tif(opts === undefined) opts = {};\n\tif (scope.defineAttribute) {\n\t\treturn scope.defineAttribute(name,opts);\n\t};\n\t\n\tlet getName = Imba.toCamelCase(name);\n\tlet setName = Imba.toCamelCase('set-' + name);\n\tlet proto = scope.prototype;\n\t\n\tif (opts.dom) {\n\t\tproto[getName] = function() { return this.dom()[name]; };\n\t\tproto[setName] = function(value) {\n\t\t\tif (value != this[name]()) {\n\t\t\t\tthis.dom()[name] = value;\n\t\t\t};\n\t\t\treturn this;\n\t\t};\n\t} else {\n\t\tproto[getName] = function() { return this.getAttribute(name); };\n\t\tproto[setName] = function(value) {\n\t\t\tthis.setAttribute(name,value);\n\t\t\treturn this;\n\t\t};\n\t};\n\treturn;\n};\n\nImba.propDidSet = function (object,property,val,prev){\n\tlet fn = property.watch;\n\tif (fn instanceof Function) {\n\t\tfn.call(object,val,prev,property);\n\t} else if ((typeof fn=='string'||fn instanceof String) && object[fn]) {\n\t\tobject[fn](val,prev,property);\n\t};\n\treturn;\n};\n\n\n// Basic events\nfunction emit__(event,args,node){\n\t// var node = cbs[event]\n\tvar prev,cb,ret;\n\t\n\twhile ((prev = node) && (node = node.next)){\n\t\tif (cb = node.listener) {\n\t\t\tif (node.path && cb[node.path]) {\n\t\t\t\tret = args ? cb[node.path].apply(cb,args) : cb[node.path]();\n\t\t\t} else {\n\t\t\t\t// check if it is a method?\n\t\t\t\tret = args ? cb.apply(node,args) : cb.call(node);\n\t\t\t};\n\t\t};\n\t\t\n\t\tif (node.times && --node.times <= 0) {\n\t\t\tprev.next = node.next;\n\t\t\tnode.listener = null;\n\t\t};\n\t};\n\treturn;\n};\n\n// method for registering a listener on object\nImba.listen = function (obj,event,listener,path){\n\tvar cbs,list,tail;\n\tcbs = obj.__listeners__ || (obj.__listeners__ = {});\n\tlist = cbs[event] || (cbs[event] = {});\n\ttail = list.tail || (list.tail = (list.next = {}));\n\ttail.listener = listener;\n\ttail.path = path;\n\tlist.tail = tail.next = {};\n\treturn tail;\n};\n\n// register a listener once\nImba.once = function (obj,event,listener){\n\tvar tail = Imba.listen(obj,event,listener);\n\ttail.times = 1;\n\treturn tail;\n};\n\n// remove a listener\nImba.unlisten = function (obj,event,cb,meth){\n\tvar node,prev;\n\tvar meta = obj.__listeners__;\n\tif (!meta) { return };\n\t\n\tif (node = meta[event]) {\n\t\twhile ((prev = node) && (node = node.next)){\n\t\t\tif (node == cb || node.listener == cb) {\n\t\t\t\tprev.next = node.next;\n\t\t\t\t// check for correct path as well?\n\t\t\t\tnode.listener = null;\n\t\t\t\tbreak;\n\t\t\t};\n\t\t};\n\t};\n\treturn;\n};\n\n// emit event\nImba.emit = function (obj,event,params){\n\tvar cb;\n\tif (cb = obj.__listeners__) {\n\t\tif (cb[event]) { emit__(event,params,cb[event]) };\n\t\tif (cb.all) { emit__(event,[event,params],cb.all) }; // and event != 'all'\n\t};\n\treturn;\n};\n\nImba.observeProperty = function (observer,key,trigger,target,prev){\n\tif (prev && typeof prev == 'object') {\n\t\tImba.unlisten(prev,'all',observer,trigger);\n\t};\n\tif (target && typeof target == 'object') {\n\t\tImba.listen(target,'all',observer,trigger);\n\t};\n\treturn this;\n};\n\nmodule.exports = Imba;\n\n\n//# sourceURL=webpack:///./node_modules/imba/src/imba/imba.imba?");

/***/ }),

/***/ "./node_modules/imba/src/imba/index.imba":
/*!***********************************************!*\
  !*** ./node_modules/imba/src/imba/index.imba ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var Imba = __webpack_require__(/*! ./imba */ \"./node_modules/imba/src/imba/imba.imba\");\nvar activate = false;\nif (typeof window !== 'undefined') {\n\tif (window.Imba) {\n\t\tconsole.warn((\"Imba v\" + (window.Imba.VERSION) + \" is already loaded.\"));\n\t\tImba = window.Imba;\n\t} else {\n\t\twindow.Imba = Imba;\n\t\tactivate = true;\n\t\tif (window.define && window.define.amd) {\n\t\t\twindow.define(\"imba\",[],function() { return Imba; });\n\t\t};\n\t};\n};\n\nmodule.exports = Imba;\n\nif (true) {\n\t__webpack_require__(/*! ./scheduler */ \"./node_modules/imba/src/imba/scheduler.imba\");\n\t__webpack_require__(/*! ./dom/index */ \"./node_modules/imba/src/imba/dom/index.imba\");\n};\n\nif (true && activate) {\n\tImba.EventManager.activate();\n};\n\nif (false) {};\n\n\n//# sourceURL=webpack:///./node_modules/imba/src/imba/index.imba?");

/***/ }),

/***/ "./node_modules/imba/src/imba/scheduler.imba":
/*!***************************************************!*\
  !*** ./node_modules/imba/src/imba/scheduler.imba ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };\nvar Imba = __webpack_require__(/*! ./imba */ \"./node_modules/imba/src/imba/imba.imba\");\n\nvar requestAnimationFrame; // very simple raf polyfill\nvar cancelAnimationFrame;\n\nif (false) {};\n\nif (true) {\n\tcancelAnimationFrame = window.cancelAnimationFrame || window.mozCancelAnimationFrame || window.webkitRequestAnimationFrame;\n\trequestAnimationFrame = window.requestAnimationFrame;\n\trequestAnimationFrame || (requestAnimationFrame = window.webkitRequestAnimationFrame);\n\trequestAnimationFrame || (requestAnimationFrame = window.mozRequestAnimationFrame);\n\trequestAnimationFrame || (requestAnimationFrame = function(blk) { return setTimeout(blk,1000 / 60); });\n};\n\nfunction Ticker(){\n\tvar self = this;\n\tself._queue = [];\n\tself._stage = -1;\n\tself._scheduled = false;\n\tself._ticker = function(e) {\n\t\tself._scheduled = false;\n\t\treturn self.tick(e);\n\t};\n\tself;\n};\n\nTicker.prototype.stage = function(v){ return this._stage; }\nTicker.prototype.setStage = function(v){ this._stage = v; return this; };\nTicker.prototype.queue = function(v){ return this._queue; }\nTicker.prototype.setQueue = function(v){ this._queue = v; return this; };\n\nTicker.prototype.add = function (item,force){\n\tif (force || this._queue.indexOf(item) == -1) {\n\t\tthis._queue.push(item);\n\t};\n\t\n\tif (!this._scheduled) { return this.schedule() };\n};\n\nTicker.prototype.tick = function (timestamp){\n\tvar items = this._queue;\n\tif (!this._ts) { this._ts = timestamp };\n\tthis._dt = timestamp - this._ts;\n\tthis._ts = timestamp;\n\tthis._queue = [];\n\tthis._stage = 1;\n\tthis.before();\n\tif (items.length) {\n\t\tfor (let i = 0, ary = iter$(items), len = ary.length, item; i < len; i++) {\n\t\t\titem = ary[i];\n\t\t\tif (item instanceof Function) {\n\t\t\t\titem(this._dt,this);\n\t\t\t} else if (item.tick) {\n\t\t\t\titem.tick(this._dt,this);\n\t\t\t};\n\t\t};\n\t};\n\tthis._stage = 2;\n\tthis.after();\n\tthis._stage = this._scheduled ? 0 : (-1);\n\treturn this;\n};\n\nTicker.prototype.schedule = function (){\n\tif (!this._scheduled) {\n\t\tthis._scheduled = true;\n\t\tif (this._stage == -1) {\n\t\t\tthis._stage = 0;\n\t\t};\n\t\trequestAnimationFrame(this._ticker);\n\t};\n\treturn this;\n};\n\nTicker.prototype.before = function (){\n\treturn this;\n};\n\nTicker.prototype.after = function (){\n\tif (Imba.TagManager) {\n\t\tImba.TagManager.refresh();\n\t};\n\treturn this;\n};\n\nImba.TICKER = new Ticker();\nImba.SCHEDULERS = [];\n\nImba.ticker = function (){\n\treturn Imba.TICKER;\n};\n\nImba.requestAnimationFrame = function (callback){\n\treturn requestAnimationFrame(callback);\n};\n\nImba.cancelAnimationFrame = function (id){\n\treturn cancelAnimationFrame(id);\n};\n\n// should add an Imba.run / setImmediate that\n// pushes listener onto the tick-queue with times - once\n\nvar commitQueue = 0;\n\nImba.commit = function (params){\n\tcommitQueue++;\n\t// Imba.TagManager.refresh\n\tImba.emit(Imba,'commit',(params != undefined) ? [params] : undefined);\n\tif (--commitQueue == 0) {\n\t\tImba.TagManager && Imba.TagManager.refresh();\n\t};\n\treturn;\n};\n\n/*\n\nInstances of Imba.Scheduler manages when to call `tick()` on their target,\nat a specified framerate or when certain events occur. Root-nodes in your\napplications will usually have a scheduler to make sure they rerender when\nsomething changes. It is also possible to make inner components use their\nown schedulers to control when they render.\n\n@iname scheduler\n\n*/\n\nImba.Scheduler = function Scheduler(target){\n\tvar self = this;\n\tself._id = counter++;\n\tself._target = target;\n\tself._marked = false;\n\tself._active = false;\n\tself._marker = function() { return self.mark(); };\n\tself._ticker = function(e) { return self.tick(e); };\n\t\n\tself._dt = 0;\n\tself._frame = {};\n\tself._scheduled = false;\n\tself._timestamp = 0;\n\tself._ticks = 0;\n\tself._flushes = 0;\n\t\n\tself.onevent = self.onevent.bind(self);\n\tself;\n};\n\nvar counter = 0;\n\nImba.Scheduler.event = function (e){\n\treturn Imba.emit(Imba,'event',e);\n};\n\n/*\n\tCreate a new Imba.Scheduler for specified target\n\t@return {Imba.Scheduler}\n\t*/\n\nImba.Scheduler.prototype.__raf = {watch: 'rafDidSet',name: 'raf'};\nImba.Scheduler.prototype.raf = function(v){ return this._raf; }\nImba.Scheduler.prototype.setRaf = function(v){\n\tvar a = this.raf();\n\tif(v != a) { this._raf = v; }\n\tif(v != a) { this.rafDidSet && this.rafDidSet(v,a,this.__raf) }\n\treturn this;\n};\nImba.Scheduler.prototype.__interval = {watch: 'intervalDidSet',name: 'interval'};\nImba.Scheduler.prototype.interval = function(v){ return this._interval; }\nImba.Scheduler.prototype.setInterval = function(v){\n\tvar a = this.interval();\n\tif(v != a) { this._interval = v; }\n\tif(v != a) { this.intervalDidSet && this.intervalDidSet(v,a,this.__interval) }\n\treturn this;\n};\nImba.Scheduler.prototype.__events = {watch: 'eventsDidSet',name: 'events'};\nImba.Scheduler.prototype.events = function(v){ return this._events; }\nImba.Scheduler.prototype.setEvents = function(v){\n\tvar a = this.events();\n\tif(v != a) { this._events = v; }\n\tif(v != a) { this.eventsDidSet && this.eventsDidSet(v,a,this.__events) }\n\treturn this;\n};\nImba.Scheduler.prototype.marked = function(v){ return this._marked; }\nImba.Scheduler.prototype.setMarked = function(v){ this._marked = v; return this; };\n\nImba.Scheduler.prototype.rafDidSet = function (bool){\n\tif (bool && this._active) this.requestTick();\n\treturn this;\n};\n\nImba.Scheduler.prototype.intervalDidSet = function (time){\n\tclearInterval(this._intervalId);\n\tthis._intervalId = null;\n\tif (time && this._active) {\n\t\tthis._intervalId = setInterval(this.oninterval.bind(this),time);\n\t};\n\treturn this;\n};\n\nImba.Scheduler.prototype.eventsDidSet = function (new$,prev){\n\tif (this._active && new$ && !prev) {\n\t\treturn Imba.listen(Imba,'commit',this,'onevent');\n\t} else if (!(new$) && prev) {\n\t\treturn Imba.unlisten(Imba,'commit',this,'onevent');\n\t};\n};\n\n/*\n\tCheck whether the current scheduler is active or not\n\t@return {bool}\n\t*/\n\nImba.Scheduler.prototype.active = function (){\n\treturn this._active;\n};\n\n/*\n\tDelta time between the two last ticks\n\t@return {Number}\n\t*/\n\nImba.Scheduler.prototype.dt = function (){\n\treturn this._dt;\n};\n\n/*\n\tConfigure the scheduler\n\t@return {self}\n\t*/\n\nImba.Scheduler.prototype.configure = function (options){\n\tvar v_;\n\tif(options === undefined) options = {};\n\tif (options.raf != undefined) { (this.setRaf(v_ = options.raf),v_) };\n\tif (options.interval != undefined) { (this.setInterval(v_ = options.interval),v_) };\n\tif (options.events != undefined) { (this.setEvents(v_ = options.events),v_) };\n\treturn this;\n};\n\n/*\n\tMark the scheduler as dirty. This will make sure that\n\tthe scheduler calls `target.tick` on the next frame\n\t@return {self}\n\t*/\n\nImba.Scheduler.prototype.mark = function (){\n\tthis._marked = true;\n\tif (!this._scheduled) {\n\t\tthis.requestTick();\n\t};\n\treturn this;\n};\n\n/*\n\tInstantly trigger target.tick and mark scheduler as clean (not dirty/marked).\n\tThis is called implicitly from tick, but can also be called manually if you\n\treally want to force a tick without waiting for the next frame.\n\t@return {self}\n\t*/\n\nImba.Scheduler.prototype.flush = function (){\n\tthis._flushes++;\n\tthis._target.tick(this);\n\tthis._marked = false;\n\treturn this;\n};\n\n/*\n\t@fixme this expects raf to run at 60 fps \n\n\tCalled automatically on every frame while the scheduler is active.\n\tIt will only call `target.tick` if the scheduler is marked dirty,\n\tor when according to @fps setting.\n\n\tIf you have set up a scheduler with an fps of 1, tick will still be\n\tcalled every frame, but `target.tick` will only be called once every\n\tsecond, and it will *make sure* each `target.tick` happens in separate\n\tseconds according to Date. So if you have a node that renders a clock\n\tbased on Date.now (or something similar), you can schedule it with 1fps,\n\tnever needing to worry about two ticks happening within the same second.\n\tThe same goes for 4fps, 10fps etc.\n\n\t@protected\n\t@return {self}\n\t*/\n\nImba.Scheduler.prototype.tick = function (delta,ticker){\n\tthis._ticks++;\n\tthis._dt = delta;\n\t\n\tif (ticker) {\n\t\tthis._scheduled = false;\n\t};\n\t\n\tthis.flush();\n\t\n\tif (this._raf && this._active) {\n\t\tthis.requestTick();\n\t};\n\treturn this;\n};\n\nImba.Scheduler.prototype.requestTick = function (){\n\tif (!this._scheduled) {\n\t\tthis._scheduled = true;\n\t\tImba.TICKER.add(this);\n\t};\n\treturn this;\n};\n\n/*\n\tStart the scheduler if it is not already active.\n\t**While active**, the scheduler will override `target.commit`\n\tto do nothing. By default Imba.tag#commit calls render, so\n\tthat rendering is cascaded through to children when rendering\n\ta node. When a scheduler is active (for a node), Imba disables\n\tthis automatic rendering.\n\t*/\n\nImba.Scheduler.prototype.activate = function (immediate){\n\tif(immediate === undefined) immediate = true;\n\tif (!this._active) {\n\t\tthis._active = true;\n\t\tthis._commit = this._target.commit;\n\t\tthis._target.commit = function() { return this; };\n\t\tthis._target && this._target.flag  &&  this._target.flag('scheduled_');\n\t\tImba.SCHEDULERS.push(this);\n\t\t\n\t\tif (this._events) {\n\t\t\tImba.listen(Imba,'commit',this,'onevent');\n\t\t};\n\t\t\n\t\tif (this._interval && !this._intervalId) {\n\t\t\tthis._intervalId = setInterval(this.oninterval.bind(this),this._interval);\n\t\t};\n\t\t\n\t\tif (immediate) {\n\t\t\tthis.tick(0);\n\t\t} else if (this._raf) {\n\t\t\tthis.requestTick();\n\t\t};\n\t};\n\treturn this;\n};\n\n/*\n\tStop the scheduler if it is active.\n\t*/\n\nImba.Scheduler.prototype.deactivate = function (){\n\tif (this._active) {\n\t\tthis._active = false;\n\t\tthis._target.commit = this._commit;\n\t\tlet idx = Imba.SCHEDULERS.indexOf(this);\n\t\tif (idx >= 0) {\n\t\t\tImba.SCHEDULERS.splice(idx,1);\n\t\t};\n\t\t\n\t\tif (this._events) {\n\t\t\tImba.unlisten(Imba,'commit',this,'onevent');\n\t\t};\n\t\t\n\t\tif (this._intervalId) {\n\t\t\tclearInterval(this._intervalId);\n\t\t\tthis._intervalId = null;\n\t\t};\n\t\t\n\t\tthis._target && this._target.unflag  &&  this._target.unflag('scheduled_');\n\t};\n\treturn this;\n};\n\nImba.Scheduler.prototype.track = function (){\n\treturn this._marker;\n};\n\nImba.Scheduler.prototype.oninterval = function (){\n\tthis.tick();\n\tImba.TagManager.refresh();\n\treturn this;\n};\n\nImba.Scheduler.prototype.onevent = function (event){\n\tif (!this._events || this._marked) { return this };\n\t\n\tif (this._events instanceof Function) {\n\t\tif (this._events(event,this)) this.mark();\n\t} else if (this._events instanceof Array) {\n\t\tif (this._events.indexOf((event && event.type) || event) >= 0) {\n\t\t\tthis.mark();\n\t\t};\n\t} else {\n\t\tthis.mark();\n\t};\n\treturn this;\n};\n\n\n//# sourceURL=webpack:///./node_modules/imba/src/imba/scheduler.imba?");

/***/ }),

/***/ "./node_modules/style-loader/lib/addStyles.js":
/*!****************************************************!*\
  !*** ./node_modules/style-loader/lib/addStyles.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\nvar stylesInDom = {};\n\nvar\tmemoize = function (fn) {\n\tvar memo;\n\n\treturn function () {\n\t\tif (typeof memo === \"undefined\") memo = fn.apply(this, arguments);\n\t\treturn memo;\n\t};\n};\n\nvar isOldIE = memoize(function () {\n\t// Test for IE <= 9 as proposed by Browserhacks\n\t// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805\n\t// Tests for existence of standard globals is to allow style-loader\n\t// to operate correctly into non-standard environments\n\t// @see https://github.com/webpack-contrib/style-loader/issues/177\n\treturn window && document && document.all && !window.atob;\n});\n\nvar getTarget = function (target) {\n  return document.querySelector(target);\n};\n\nvar getElement = (function (fn) {\n\tvar memo = {};\n\n\treturn function(target) {\n                // If passing function in options, then use it for resolve \"head\" element.\n                // Useful for Shadow Root style i.e\n                // {\n                //   insertInto: function () { return document.querySelector(\"#foo\").shadowRoot }\n                // }\n                if (typeof target === 'function') {\n                        return target();\n                }\n                if (typeof memo[target] === \"undefined\") {\n\t\t\tvar styleTarget = getTarget.call(this, target);\n\t\t\t// Special case to return head of iframe instead of iframe itself\n\t\t\tif (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n\t\t\t\ttry {\n\t\t\t\t\t// This will throw an exception if access to iframe is blocked\n\t\t\t\t\t// due to cross-origin restrictions\n\t\t\t\t\tstyleTarget = styleTarget.contentDocument.head;\n\t\t\t\t} catch(e) {\n\t\t\t\t\tstyleTarget = null;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmemo[target] = styleTarget;\n\t\t}\n\t\treturn memo[target]\n\t};\n})();\n\nvar singleton = null;\nvar\tsingletonCounter = 0;\nvar\tstylesInsertedAtTop = [];\n\nvar\tfixUrls = __webpack_require__(/*! ./urls */ \"./node_modules/style-loader/lib/urls.js\");\n\nmodule.exports = function(list, options) {\n\tif (typeof DEBUG !== \"undefined\" && DEBUG) {\n\t\tif (typeof document !== \"object\") throw new Error(\"The style-loader cannot be used in a non-browser environment\");\n\t}\n\n\toptions = options || {};\n\n\toptions.attrs = typeof options.attrs === \"object\" ? options.attrs : {};\n\n\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n\t// tags it will allow on a page\n\tif (!options.singleton && typeof options.singleton !== \"boolean\") options.singleton = isOldIE();\n\n\t// By default, add <style> tags to the <head> element\n        if (!options.insertInto) options.insertInto = \"head\";\n\n\t// By default, add <style> tags to the bottom of the target\n\tif (!options.insertAt) options.insertAt = \"bottom\";\n\n\tvar styles = listToStyles(list, options);\n\n\taddStylesToDom(styles, options);\n\n\treturn function update (newList) {\n\t\tvar mayRemove = [];\n\n\t\tfor (var i = 0; i < styles.length; i++) {\n\t\t\tvar item = styles[i];\n\t\t\tvar domStyle = stylesInDom[item.id];\n\n\t\t\tdomStyle.refs--;\n\t\t\tmayRemove.push(domStyle);\n\t\t}\n\n\t\tif(newList) {\n\t\t\tvar newStyles = listToStyles(newList, options);\n\t\t\taddStylesToDom(newStyles, options);\n\t\t}\n\n\t\tfor (var i = 0; i < mayRemove.length; i++) {\n\t\t\tvar domStyle = mayRemove[i];\n\n\t\t\tif(domStyle.refs === 0) {\n\t\t\t\tfor (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();\n\n\t\t\t\tdelete stylesInDom[domStyle.id];\n\t\t\t}\n\t\t}\n\t};\n};\n\nfunction addStylesToDom (styles, options) {\n\tfor (var i = 0; i < styles.length; i++) {\n\t\tvar item = styles[i];\n\t\tvar domStyle = stylesInDom[item.id];\n\n\t\tif(domStyle) {\n\t\t\tdomStyle.refs++;\n\n\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\n\t\t\t\tdomStyle.parts[j](item.parts[j]);\n\t\t\t}\n\n\t\t\tfor(; j < item.parts.length; j++) {\n\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\t\t} else {\n\t\t\tvar parts = [];\n\n\t\t\tfor(var j = 0; j < item.parts.length; j++) {\n\t\t\t\tparts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\n\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\n\t\t}\n\t}\n}\n\nfunction listToStyles (list, options) {\n\tvar styles = [];\n\tvar newStyles = {};\n\n\tfor (var i = 0; i < list.length; i++) {\n\t\tvar item = list[i];\n\t\tvar id = options.base ? item[0] + options.base : item[0];\n\t\tvar css = item[1];\n\t\tvar media = item[2];\n\t\tvar sourceMap = item[3];\n\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\n\n\t\tif(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});\n\t\telse newStyles[id].parts.push(part);\n\t}\n\n\treturn styles;\n}\n\nfunction insertStyleElement (options, style) {\n\tvar target = getElement(options.insertInto)\n\n\tif (!target) {\n\t\tthrow new Error(\"Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.\");\n\t}\n\n\tvar lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];\n\n\tif (options.insertAt === \"top\") {\n\t\tif (!lastStyleElementInsertedAtTop) {\n\t\t\ttarget.insertBefore(style, target.firstChild);\n\t\t} else if (lastStyleElementInsertedAtTop.nextSibling) {\n\t\t\ttarget.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);\n\t\t} else {\n\t\t\ttarget.appendChild(style);\n\t\t}\n\t\tstylesInsertedAtTop.push(style);\n\t} else if (options.insertAt === \"bottom\") {\n\t\ttarget.appendChild(style);\n\t} else if (typeof options.insertAt === \"object\" && options.insertAt.before) {\n\t\tvar nextSibling = getElement(options.insertInto + \" \" + options.insertAt.before);\n\t\ttarget.insertBefore(style, nextSibling);\n\t} else {\n\t\tthrow new Error(\"[Style Loader]\\n\\n Invalid value for parameter 'insertAt' ('options.insertAt') found.\\n Must be 'top', 'bottom', or Object.\\n (https://github.com/webpack-contrib/style-loader#insertat)\\n\");\n\t}\n}\n\nfunction removeStyleElement (style) {\n\tif (style.parentNode === null) return false;\n\tstyle.parentNode.removeChild(style);\n\n\tvar idx = stylesInsertedAtTop.indexOf(style);\n\tif(idx >= 0) {\n\t\tstylesInsertedAtTop.splice(idx, 1);\n\t}\n}\n\nfunction createStyleElement (options) {\n\tvar style = document.createElement(\"style\");\n\n\tif(options.attrs.type === undefined) {\n\t\toptions.attrs.type = \"text/css\";\n\t}\n\n\taddAttrs(style, options.attrs);\n\tinsertStyleElement(options, style);\n\n\treturn style;\n}\n\nfunction createLinkElement (options) {\n\tvar link = document.createElement(\"link\");\n\n\tif(options.attrs.type === undefined) {\n\t\toptions.attrs.type = \"text/css\";\n\t}\n\toptions.attrs.rel = \"stylesheet\";\n\n\taddAttrs(link, options.attrs);\n\tinsertStyleElement(options, link);\n\n\treturn link;\n}\n\nfunction addAttrs (el, attrs) {\n\tObject.keys(attrs).forEach(function (key) {\n\t\tel.setAttribute(key, attrs[key]);\n\t});\n}\n\nfunction addStyle (obj, options) {\n\tvar style, update, remove, result;\n\n\t// If a transform function was defined, run it on the css\n\tif (options.transform && obj.css) {\n\t    result = options.transform(obj.css);\n\n\t    if (result) {\n\t    \t// If transform returns a value, use that instead of the original css.\n\t    \t// This allows running runtime transformations on the css.\n\t    \tobj.css = result;\n\t    } else {\n\t    \t// If the transform function returns a falsy value, don't add this css.\n\t    \t// This allows conditional loading of css\n\t    \treturn function() {\n\t    \t\t// noop\n\t    \t};\n\t    }\n\t}\n\n\tif (options.singleton) {\n\t\tvar styleIndex = singletonCounter++;\n\n\t\tstyle = singleton || (singleton = createStyleElement(options));\n\n\t\tupdate = applyToSingletonTag.bind(null, style, styleIndex, false);\n\t\tremove = applyToSingletonTag.bind(null, style, styleIndex, true);\n\n\t} else if (\n\t\tobj.sourceMap &&\n\t\ttypeof URL === \"function\" &&\n\t\ttypeof URL.createObjectURL === \"function\" &&\n\t\ttypeof URL.revokeObjectURL === \"function\" &&\n\t\ttypeof Blob === \"function\" &&\n\t\ttypeof btoa === \"function\"\n\t) {\n\t\tstyle = createLinkElement(options);\n\t\tupdate = updateLink.bind(null, style, options);\n\t\tremove = function () {\n\t\t\tremoveStyleElement(style);\n\n\t\t\tif(style.href) URL.revokeObjectURL(style.href);\n\t\t};\n\t} else {\n\t\tstyle = createStyleElement(options);\n\t\tupdate = applyToTag.bind(null, style);\n\t\tremove = function () {\n\t\t\tremoveStyleElement(style);\n\t\t};\n\t}\n\n\tupdate(obj);\n\n\treturn function updateStyle (newObj) {\n\t\tif (newObj) {\n\t\t\tif (\n\t\t\t\tnewObj.css === obj.css &&\n\t\t\t\tnewObj.media === obj.media &&\n\t\t\t\tnewObj.sourceMap === obj.sourceMap\n\t\t\t) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tupdate(obj = newObj);\n\t\t} else {\n\t\t\tremove();\n\t\t}\n\t};\n}\n\nvar replaceText = (function () {\n\tvar textStore = [];\n\n\treturn function (index, replacement) {\n\t\ttextStore[index] = replacement;\n\n\t\treturn textStore.filter(Boolean).join('\\n');\n\t};\n})();\n\nfunction applyToSingletonTag (style, index, remove, obj) {\n\tvar css = remove ? \"\" : obj.css;\n\n\tif (style.styleSheet) {\n\t\tstyle.styleSheet.cssText = replaceText(index, css);\n\t} else {\n\t\tvar cssNode = document.createTextNode(css);\n\t\tvar childNodes = style.childNodes;\n\n\t\tif (childNodes[index]) style.removeChild(childNodes[index]);\n\n\t\tif (childNodes.length) {\n\t\t\tstyle.insertBefore(cssNode, childNodes[index]);\n\t\t} else {\n\t\t\tstyle.appendChild(cssNode);\n\t\t}\n\t}\n}\n\nfunction applyToTag (style, obj) {\n\tvar css = obj.css;\n\tvar media = obj.media;\n\n\tif(media) {\n\t\tstyle.setAttribute(\"media\", media)\n\t}\n\n\tif(style.styleSheet) {\n\t\tstyle.styleSheet.cssText = css;\n\t} else {\n\t\twhile(style.firstChild) {\n\t\t\tstyle.removeChild(style.firstChild);\n\t\t}\n\n\t\tstyle.appendChild(document.createTextNode(css));\n\t}\n}\n\nfunction updateLink (link, options, obj) {\n\tvar css = obj.css;\n\tvar sourceMap = obj.sourceMap;\n\n\t/*\n\t\tIf convertToAbsoluteUrls isn't defined, but sourcemaps are enabled\n\t\tand there is no publicPath defined then lets turn convertToAbsoluteUrls\n\t\ton by default.  Otherwise default to the convertToAbsoluteUrls option\n\t\tdirectly\n\t*/\n\tvar autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;\n\n\tif (options.convertToAbsoluteUrls || autoFixUrls) {\n\t\tcss = fixUrls(css);\n\t}\n\n\tif (sourceMap) {\n\t\t// http://stackoverflow.com/a/26603875\n\t\tcss += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \" */\";\n\t}\n\n\tvar blob = new Blob([css], { type: \"text/css\" });\n\n\tvar oldSrc = link.href;\n\n\tlink.href = URL.createObjectURL(blob);\n\n\tif(oldSrc) URL.revokeObjectURL(oldSrc);\n}\n\n\n//# sourceURL=webpack:///./node_modules/style-loader/lib/addStyles.js?");

/***/ }),

/***/ "./node_modules/style-loader/lib/urls.js":
/*!***********************************************!*\
  !*** ./node_modules/style-loader/lib/urls.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("\n/**\n * When source maps are enabled, `style-loader` uses a link element with a data-uri to\n * embed the css on the page. This breaks all relative urls because now they are relative to a\n * bundle instead of the current page.\n *\n * One solution is to only use full urls, but that may be impossible.\n *\n * Instead, this function \"fixes\" the relative urls to be absolute according to the current page location.\n *\n * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.\n *\n */\n\nmodule.exports = function (css) {\n  // get current location\n  var location = typeof window !== \"undefined\" && window.location;\n\n  if (!location) {\n    throw new Error(\"fixUrls requires window.location\");\n  }\n\n\t// blank or null?\n\tif (!css || typeof css !== \"string\") {\n\t  return css;\n  }\n\n  var baseUrl = location.protocol + \"//\" + location.host;\n  var currentDir = baseUrl + location.pathname.replace(/\\/[^\\/]*$/, \"/\");\n\n\t// convert each url(...)\n\t/*\n\tThis regular expression is just a way to recursively match brackets within\n\ta string.\n\n\t /url\\s*\\(  = Match on the word \"url\" with any whitespace after it and then a parens\n\t   (  = Start a capturing group\n\t     (?:  = Start a non-capturing group\n\t         [^)(]  = Match anything that isn't a parentheses\n\t         |  = OR\n\t         \\(  = Match a start parentheses\n\t             (?:  = Start another non-capturing groups\n\t                 [^)(]+  = Match anything that isn't a parentheses\n\t                 |  = OR\n\t                 \\(  = Match a start parentheses\n\t                     [^)(]*  = Match anything that isn't a parentheses\n\t                 \\)  = Match a end parentheses\n\t             )  = End Group\n              *\\) = Match anything and then a close parens\n          )  = Close non-capturing group\n          *  = Match anything\n       )  = Close capturing group\n\t \\)  = Match a close parens\n\n\t /gi  = Get all matches, not the first.  Be case insensitive.\n\t */\n\tvar fixedCss = css.replace(/url\\s*\\(((?:[^)(]|\\((?:[^)(]+|\\([^)(]*\\))*\\))*)\\)/gi, function(fullMatch, origUrl) {\n\t\t// strip quotes (if they exist)\n\t\tvar unquotedOrigUrl = origUrl\n\t\t\t.trim()\n\t\t\t.replace(/^\"(.*)\"$/, function(o, $1){ return $1; })\n\t\t\t.replace(/^'(.*)'$/, function(o, $1){ return $1; });\n\n\t\t// already a full url? no change\n\t\tif (/^(#|data:|http:\\/\\/|https:\\/\\/|file:\\/\\/\\/|\\s*$)/i.test(unquotedOrigUrl)) {\n\t\t  return fullMatch;\n\t\t}\n\n\t\t// convert the url to a full url\n\t\tvar newUrl;\n\n\t\tif (unquotedOrigUrl.indexOf(\"//\") === 0) {\n\t\t  \t//TODO: should we add protocol?\n\t\t\tnewUrl = unquotedOrigUrl;\n\t\t} else if (unquotedOrigUrl.indexOf(\"/\") === 0) {\n\t\t\t// path should be relative to the base url\n\t\t\tnewUrl = baseUrl + unquotedOrigUrl; // already starts with '/'\n\t\t} else {\n\t\t\t// path should be relative to current directory\n\t\t\tnewUrl = currentDir + unquotedOrigUrl.replace(/^\\.\\//, \"\"); // Strip leading './'\n\t\t}\n\n\t\t// send back the fixed url(...)\n\t\treturn \"url(\" + JSON.stringify(newUrl) + \")\";\n\t});\n\n\t// send back the fixed css\n\treturn fixedCss;\n};\n\n\n//# sourceURL=webpack:///./node_modules/style-loader/lib/urls.js?");

/***/ }),

/***/ "./src/button/button.imba":
/*!********************************!*\
  !*** ./src/button/button.imba ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var Imba = __webpack_require__(/*! imba */ \"./node_modules/imba/imba.imba\"), _1 = Imba.createElement;\nvar MDCRipple = __webpack_require__(/*! @material/ripple */ \"./node_modules/@material/ripple/index.js\").MDCRipple;\n__webpack_require__(/*! @material/button/mdc-button.scss */ \"./node_modules/@material/button/mdc-button.scss\");\nvar Icon = __webpack_require__(/*! ../icon/icon */ \"./src/icon/icon.imba\").Icon;\n\nvar Button = Imba.defineTag('Button', function(tag){\n\ttag.prototype.raised = function(v){ return this._raised; }\n\ttag.prototype.setRaised = function(v){ this._raised = v; return this; };\n\ttag.prototype.flat = function(v){ return this._flat; }\n\ttag.prototype.setFlat = function(v){ this._flat = v; return this; };\n\ttag.prototype.outlined = function(v){ return this._outlined; }\n\ttag.prototype.setOutlined = function(v){ this._outlined = v; return this; };\n\ttag.prototype.disabled = function(v){ return this._disabled; }\n\ttag.prototype.setDisabled = function(v){ this._disabled = v; return this; };\n\ttag.prototype.ripple = function(v){ return this._ripple; }\n\ttag.prototype.setRipple = function(v){ this._ripple = v; return this; };\n\ttag.prototype.text = function(v){ return this._text; }\n\ttag.prototype.setText = function(v){ this._text = v; return this; };\n\ttag.prototype.icon = function(v){ return this._icon; }\n\ttag.prototype.setIcon = function(v){ this._icon = v; return this; };\n\t\n\ttag.prototype.mount = function (){\n\t\tif (this._ripple) {\n\t\t\treturn new MDCRipple(this._dom.children[0]);\n\t\t};\n\t};\n\t\n\ttag.prototype.render = function (){\n\t\tvar $ = this.$;\n\t\treturn this.$open(0).setChildren(\n\t\t\t$[0] || _1('button',$,0,this).flag('mdc-button')\n\t\t,2).synced((\n\t\t\t$[0].flagIf('mdc-button--raised',this._raised).flagIf('mdc-button--outlined',this._outlined).flagIf('mdc-button--unelevated',this.flat()).setDisabled(this._disabled).setContent([\n\t\t\t\tthis._icon ? (\n\t\t\t\t\t($[1] || _1(Icon,$,1,0).setInbutton(true)).setIcon(this._icon).end()\n\t\t\t\t) : void(0),\n\t\t\t\tthis._text\n\t\t\t],1).end()\n\t\t,true));\n\t};\n})\nexports.Button = Button;\n\n\n\n//# sourceURL=webpack:///./src/button/button.imba?");

/***/ }),

/***/ "./src/client.imba":
/*!*************************!*\
  !*** ./src/client.imba ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var Imba = __webpack_require__(/*! imba */ \"./node_modules/imba/imba.imba\"), _1 = Imba.createElement;\nvar Button = __webpack_require__(/*! ./button/button */ \"./src/button/button.imba\").Button;\nvar icon$ = __webpack_require__(/*! ./icon/icon */ \"./src/icon/icon.imba\"), Icon = icon$.Icon, Sizes = icon$.Sizes;\nvar grid$ = __webpack_require__(/*! ./grid/grid */ \"./src/grid/grid.imba\"), Grid = grid$.Grid, Row = grid$.Row, Column = grid$.Column;\nvar store = {};\n\nvar App = Imba.defineTag('App', function(tag){\n\ttag.prototype.render = function (){\n\t\tvar $ = this.$;\n\t\treturn this.$open(0).setChildren(\n\t\t\t$[0] || _1(Grid,$,0,this).setContent(\n\t\t\t\t$[1] || _1(Row,$,1,0).setContent(\n\t\t\t\t\t$[2] || _1(Column,$,2,1).setContent(\n\t\t\t\t\t\t$[3] || _1('div',$,3,2).setText(\"This makes me sad\")\n\t\t\t\t\t,2)\n\t\t\t\t,2)\n\t\t\t,2)\n\t\t,2).synced((\n\t\t\t$[0].end((\n\t\t\t\t$[1].end((\n\t\t\t\t\t$[2].end()\n\t\t\t\t,true))\n\t\t\t,true))\n\t\t,true));\n\t};\n});\n\nImba.mount((_1(App)).setData(store).end());\n\n\n//# sourceURL=webpack:///./src/client.imba?");

/***/ }),

/***/ "./src/grid/grid.imba":
/*!****************************!*\
  !*** ./src/grid/grid.imba ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var Imba = __webpack_require__(/*! imba */ \"./node_modules/imba/imba.imba\"), _1 = Imba.createElement;\nvar Grid = Imba.defineTag('Grid', function(tag){\n\ttag.prototype.render = function (){\n\t\tvar $ = this.$;\n\t\treturn this.$open(0).setChildren(\n\t\t\t$[0] || _1('div',$,0,this).flag('mdc-layout-grid')\n\t\t,2).synced((\n\t\t\t$[0].setContent(\n\t\t\t\tthis._dom.children\n\t\t\t,3)\n\t\t,true));\n\t};\n})\nexports.Grid = Grid;\n\nvar Column = Imba.defineTag('Column', function(tag){\n\ttag.prototype.render = function (){\n\t\tvar $ = this.$;\n\t\treturn this.$open(0).setChildren(\n\t\t\t$[0] || _1('div',$,0,this).flag('mdc-layout-grid__cell')\n\t\t,2).synced((\n\t\t\t$[0].setContent(\n\t\t\t\tthis._dom.children\n\t\t\t,3)\n\t\t,true));\n\t};\n})\nexports.Column = Column;\n\nvar Row = Imba.defineTag('Row', function(tag){\n\ttag.prototype.render = function (){\n\t\tvar $ = this.$;\n\t\treturn this.$open(0).setChildren(\n\t\t\t$[0] || _1('div',$,0,this).flag('mdc-layout-grid__inner')\n\t\t,2).synced((\n\t\t\t$[0].setContent(\n\t\t\t\tthis._dom.children\n\t\t\t,3)\n\t\t,true));\n\t};\n})\nexports.Row = Row;\n\n\n//# sourceURL=webpack:///./src/grid/grid.imba?");

/***/ }),

/***/ "./src/icon/icon.imba":
/*!****************************!*\
  !*** ./src/icon/icon.imba ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var Imba = __webpack_require__(/*! imba */ \"./node_modules/imba/imba.imba\"), _1 = Imba.createElement;\n\nvar mapping$ = __webpack_require__(/*! ./mapping */ \"./src/icon/mapping.imba\"), sizes = mapping$.sizes, light = mapping$.light, dark = mapping$.dark, mdInactive = mapping$.mdInactive;\n__webpack_require__(/*! ./index.css */ \"./src/icon/index.css\");;\n\nvar Sizes = exports.Sizes = sizes;\n\nvar Icon = Imba.defineTag('Icon', function(tag){\n\ttag.prototype.icon = function(v){ return this._icon; }\n\ttag.prototype.setIcon = function(v){ this._icon = v; return this; };\n\ttag.prototype.size = function(v){ return this._size; }\n\ttag.prototype.setSize = function(v){ this._size = v; return this; };\n\ttag.prototype.invert = function(v){ return this._invert; }\n\ttag.prototype.setInvert = function(v){ this._invert = v; return this; };\n\ttag.prototype.inactive = function(v){ return this._inactive; }\n\ttag.prototype.setInactive = function(v){ this._inactive = v; return this; };\n\ttag.prototype.color = function(v){ return this._color; }\n\ttag.prototype.setColor = function(v){ this._color = v; return this; };\n\ttag.prototype.inbutton = function(v){ return this._inbutton; }\n\ttag.prototype.setInbutton = function(v){ this._inbutton = v; return this; };\n\t\n\ttag.prototype.render = function (){\n\t\tvar $ = this.$;\n\t\t(this._color == null) ? (this._color = '') : this._color;\n\t\tvar sizeMapped = this._size || sizes.small;\n\t\tvar defaultColor = this._invert ? light : dark;\n\t\tvar inactiveColor = this._inactive ? mdInactive : '';;\n\t\t\n\t\treturn this.$open(0).setChildren(\n\t\t\t$[0] || _1('i',$,0,this).flag('material-icons')\n\t\t,2).synced((\n\t\t\t$[0].setFlag(0,sizeMapped).setFlag(1,defaultColor).setFlag(2,inactiveColor).flagIf('mdc-button__icon',this._inbutton).css('color',this._color).css('fontSize',sizeMapped).setContent(this._icon,3).end()\n\t\t,true));\n\t};\n})\nexports.Icon = Icon;\n\n\n\n\n//# sourceURL=webpack:///./src/icon/icon.imba?");

/***/ }),

/***/ "./src/icon/index.css":
/*!****************************!*\
  !*** ./src/icon/index.css ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\nvar content = __webpack_require__(/*! !../../node_modules/css-loader!../../node_modules/sass-loader/lib/loader.js??ref--5-2!./index.css */ \"./node_modules/css-loader/index.js!./node_modules/sass-loader/lib/loader.js?!./src/icon/index.css\");\n\nif(typeof content === 'string') content = [[module.i, content, '']];\n\nvar transform;\nvar insertInto;\n\n\n\nvar options = {\"hmr\":true}\n\noptions.transform = transform\noptions.insertInto = undefined;\n\nvar update = __webpack_require__(/*! ../../node_modules/style-loader/lib/addStyles.js */ \"./node_modules/style-loader/lib/addStyles.js\")(content, options);\n\nif(content.locals) module.exports = content.locals;\n\nif(false) {}\n\n//# sourceURL=webpack:///./src/icon/index.css?");

/***/ }),

/***/ "./src/icon/mapping.imba":
/*!*******************************!*\
  !*** ./src/icon/mapping.imba ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var sizes = exports.sizes = {\n\ttiny: 'md-18',\n\tsmall: 'md-24',\n\tmedium: 'md-36',\n\tlarge: 'md-48'\n};\nvar light = exports.light = 'md-light';\nvar dark = exports.dark = 'md-dark';\nvar mdInactive = exports.mdInactive = 'md-inactive';\n\n\n//# sourceURL=webpack:///./src/icon/mapping.imba?");

/***/ })

/******/ });